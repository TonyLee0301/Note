# 4 对象的组合

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

## 4.1 设计线程安全的类
&emsp;&emsp;在设计线程安全类的过程中，需要包含一下三个基本要素：
* 找出构成对象状态的所有变量。
* 找出约束状态变量的不变性条件。
* 建立对象状态的并发访问管理策略。
### 4.1.1 收集同步需求
&emsp;&emsp;要确保类的安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，则就需要对其状态进行推断。
> 如果不了解对象的不变性与后验条件，那么久不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。
### 4.1.2 依赖状态的操作
&emsp;&emsp;类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换时有效的。在某些对象的方法中还包含了一些基于状态的先验条件(Precondition)。例如：不能从空队列中移除一个元素等等。**如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作**。
### 4.1.3 状态的所有权
&emsp;&emsp;对象封装它用用的状态，反之也成立，即对它封装的状态拥有所有权。

## 4.2 实例封闭
&emsp;&emsp;封装简化了线程安全类的实现过程，它提供了一种实例封装机制(Instance Confinement)，通常也简称为“封装”[CPJ 2.3.3]。当一个对象被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。
> 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。
&emsp;&emsp;实例封装是构建线程安全类的一个最简单方式，它还使得在锁策略的选择上拥有了更多的灵活性。实例封装还使得不同的状态变量可以由不同的锁来保护。
> 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序。
### 4.2.1 Java 监视器模式
&emsp;&emsp;从线程封闭原则及其逻辑推论可以得出Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象的内置锁来保护。
&emsp;&emsp;Java监视器模式的主要优势就在于它的简单性。
&emsp;&emsp;Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。

### 4.3 线程安全型的委托
&emsp;&emsp;大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。但是，如果类中的各个组件都已经是线程安全的，视情况而定决定是否再增加一个额外的线程安全层。在某些情况下，通过多个线程安全类组合而成的类时线程安全的，而在某些情况下，这仅仅是一个好的开端。

#### 4.3.1 独立的状态变量
&emsp;&emsp;我们可以将线程安全委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。(可以理解为每个变量都是独立的，它们没有任何交集，也不会存在几个变量间的说要求的不变条件，例如4.3.2的例子。)
#### 4.3.2 当委托失效时
&emsp;&emsp;大多数组合对象在它们的状态变量之间存在着某些不变性条件。如果某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。看下面的错误代码,同时其违背了上文我们提到的独立的状态变量：
 ```java
 public class NumberRange {
    //不变条件 lower < upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper= new AtomicInteger(0);

    public void setLower(Integer i){
        //不安全的复合操作，检查 设置
        if(i > upper.get()){
            throw new IllegalArgumentException("can not set lower > upper");
        }
        lower.set(i);
    }

    public void setUpper(Integer i){
        //不安全的复合操作，检查 设置
        if(i < lower.get()){
            throw new IllegalArgumentException("can not set upper < lower");
        }
        upper.set(i);
    }

}
 ```
&emsp;&emsp;lower,upper是两个线程安全的变量，但是他们 NumberRange 却增加了一个不变条件，lower < upper 导致两个线程安全的变量不再独立。
> 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全委托给底层的状态变量。

#### 4.3.3 发布底层的状态变量
> 如果一个状态变量时线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么久可以安全地发布这个变量。

