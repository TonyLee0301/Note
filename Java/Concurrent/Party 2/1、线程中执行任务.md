# 6 线程中执行任务
## 6.1 串行地执行任务
&emsp;&emsp;在应用程序中可以通过多种策略来调度任务，而其中一个策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中串行的执行各项任务。
## 6.1.2 显示地为任务创建线程
&emsp;&emsp;通过new Runnable new Thread 等方式显示的创建线程
## 6.1.3 无限制创建线程的不足
1. 线程声明周期的开销非常高
2. 资源消耗
3. 稳定性

## 6.2 Executor 框架
&emsp;&emsp;线程池简化了线程的管理工作，并且 java.util.concurrent 提供一种灵活的线程池实现作为 Executor 框架的一部分。在Java类库中，任务执行的主要抽象不是Thread，而是Executor，如下程序：
 ```java
 public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */
    void execute(Runnable command);
}
 ```
&emsp;&emsp;Executor它灵活且强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对声明周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。
&emsp;&emsp;Executor基于生产者——消费者模式，提交任务的操作相当于生产者(生成待完成的工作单元)，执行任务的线程则相当于消费者(执行完这些工作单元)。如果要在程序中实现一个生产者——消费者的设计，那么最简单的方式就是使用Executor。

### 6.2.1 示例：基于 Executor 的 Web 服务器
&emsp;&emsp;基于 Executor 来构建Web服务器是非常容易的。下面的程序用Executor代替了硬编码的线程池创建过程。在这种情况下使用一种标准的Executor实现，即一个固定长度的线程池，可以容纳100个线程。
 ```java
 public class TaskExecutionWebServer {

    private static final int NTHREADS = 100;
    private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);

    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while(true){
            final Socket connection = socket.accept();
            Runnable task = ()->{
                handleRequest(connection);
            };
            exec.execute(task);
        }
    }

    private static void handleRequest(Socket connection){
        return;
    }
}
 ```
&emsp;&emsp;在TaskExecutionWebServer中，通过使用Executor将请求任务的提交与任务的时机执行解耦开来，并且只需采用另外一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置说带来的影响要远远小于改变任务提交方式带来的影响。通常，Executor的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地扩散到整个程序，增加了修改的难度。

### 6.2.2 执行策略
&emsp;&emsp;通过将任务的提交与执行解耦开来，从而无需太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的“What、Where、When、How”等方面，包括：
* 在什么(What)线程中执行任务？
* 任务按照什么(What)顺序执行(FIFO、LIFO、优先级)?
* 有多少个(How Many)任务并发执行？
* 在队列中有多少个(How Many)任务在等待执行？
* 如果系统由于过载而需要拒绝一个任务，那么应该选择哪个(Which)任务？另外如何(How)通知应用程序有任务被拒绝？
* 在执行一个任务之前或之后，应该进行哪些(What)动作？
&emsp;&emsp;各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上发生竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。  
  
每当看到下面这种形式的代码时:
 ```java
 new Thread(runnable).start()
 ```
并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。

### 6.2.3 线程池
&emsp;&emsp;线程池，是指管理一组同构工作线程的资源池。线程池是与工作队列(Work Queue)密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程(Work Thread)的任务简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
&emsp;&emsp;"在线程池中执行任务"比"为每个任务分配一个线程"优势更多。通过重用现有的线程池而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处就是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高响应性。通过适当调节线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，同时还可以防止过多线程互相竞争资源而使应用程序耗尽内存或失败。
&emsp;&emsp;类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池：  
* **newFixedThreadPool** 将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程发生了未预期的Exception而结束，那么线程池会补充一个新的线程)。
* **newCachedThreadPool** 将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
* **newSingleThreadExecutor** 是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另外一个线程来代替。newSingleThreadExecutor能够确保一早任务在队列中的书序来执行(例如FIFO、LIFO、优先级)。
* **newScheduledThreadPool** 创建一个固定长度的线程池，而且以延迟或定时任务的方式来执行任务，类似于TImer。
* **newFixedThreadPool**和**newCachedThreadPool**这两个工厂方法返回通用的ThreadPoolExecutor实例，这些实例可以直接用来构造专门用途的executor。