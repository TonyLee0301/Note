
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [避免活跃性危险](#避免活跃性危险)
  - [10.1 死锁](#101-死锁)

<!-- /code_chunk_output -->
# 避免活跃性危险
&emsp;&emsp;在安全性与活跃性之间通常存在某种制衡。我们使用加锁机制来确保线程安全，但如果过度地使用加锁，这可能导致锁顺序死锁(Lock-Ordering Deadlock)。同样，我们使用线程池和信号量来限制对资源对使用，但这种被限制的行为可能会导致资源死锁(Resource Deadlock)。Java应用程序无法从死锁总恢复过来，因此在设计时一定要排除哪些可能导致死锁出现的条件。

## 10.1 死锁
&emsp;&emsp;经典的“哲学家进餐”问题就很好地描述了死锁状态。
&emsp;&emsp;当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞。当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远地等待下去。这种情况就是**最简单的死锁形式(或者称为"抱死[Deadly Embrace]")**，其中多个线程由于存在环路的锁以来关系而永远地等待下去。(把每个线程假想为有向图中的一个节点，图中每条边表示的关系是：“线程A等待线程B所占有的资源”。如果在图中形成了一条环路，那么就存在一个死锁。)
&emsp;&emsp;在数据库系统的设计中考虑了检测死锁以及从死锁中恢复。在执行一个事务(Transaction)时可能需要获得多个锁，并一直持有这些锁直至事务提交。因此在两个事务之间很可能发生死锁，但事实上这种情况并不多件。如果没有外部干涉，那么这些事务将永远等待下去(在某个事务中持有的锁可能在其他事务中也需要)。但数据库服务器不会让这种情况发生。当它检测到一组事务发生了死锁时(通过在表示等待关系的有向图中搜索循环)，将选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在可以成功完成，因为所有跟它竞争资源的事务都已经完成。
&emsp;&emsp;JVM在解决死锁方面没有数据库服务器那样强大。当一组Java线程发生死锁时，“游戏”将到此结束——这些线程永远不能再使用了。根据线程完成工作的不通，可能造成应用程序完全停止，或者某个
