# 对象共享
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [对象共享](#对象共享)
  - [1 可见性](#1-可见性)
    - [1.1.失效数据](#11失效数据)
    - [1.2 非原子的64位操作](#12-非原子的64位操作)
    - [1.3 加锁与可见性](#13-加锁与可见性)
    - [1.4 Volatile 关键字](#14-volatile-关键字)
  - [2. 发布与逸出](#2-发布与逸出)

<!-- /code_chunk_output -->

## 1 可见性
&emsp;&emsp;可见性是一种复杂的属性，因为可见性的错误，总是违背我们的自觉。在单线程环境中，如果向某个变量先写入值，然后再没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。这看起分自然。然后，当读操作和写操作在不同的线程中执行时，情况却并非如此。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。**为了确保多个线程之间对内存的写入操作的可见性，必须使用同步机制。**
 ```java
 public class NoVisibility {

    private static boolean ready;

    private static int number;

    private static class ReaderThread extends Thread{
        public void run(){
            while(!ready){
                Thread.yield();
            }
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }

}
 ```
上线的代码清单，自测输出都是42，暂时未出现以下两种结果：
1. 输出0，因为读线程可能看到写入ready值，但是却没看到之后从写入number的值，这种现象被称为“重排序(Recordering)”。
2. 一直循环，因为读线程可能永远看不到ready的值。
&emsp;&emsp;只要在某个线程中无法检测到重排序情况(即是在其他线程中可以很明显地看到该线程中的重排序)，那么久无法确保线程中的操作将按照程序中指定的顺序来执行。

### 1.1.失效数据
&emsp;当读线程查看变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获取到讴歌变量的最新值，而另一个获得的是失效值。

### 1.2 非原子的64位操作
&emsp;&emsp;非volatile类型的64位数值变量(double和long)。Java类型模型要求，内存的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。incident，即是不考虑失效数据问题，在多线程程序中使用共享变量可变的long和double等类型变量也是不安全的，除非用关键字volatile来声名它们，或者用说保护起来。[JVMG规范](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7)

### 1.3 加锁与可见性
&emsp;&emsp;内置说可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确说的情况下读取某个变量，那么读到的可能是一个失效值。
&emsp;&emsp;**加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁同步。**

### 1.4 Volatile 关键字
&emsp;&emsp;Java语言提供了一种稍弱的同步机制，即 volatile 关键字，用来确保将变量变量的更新操作通知到其他线程。当**把变量声明为 volatile 后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其他内存操作一起重排序**。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此就不会使执行线程阻塞，因此volatitle是一种比sychronized关键字更轻量级的同步机制。
&emsp;&emsp;volatile 变量对可见性的影响比volatitle变量本身更重要。当线程A首先写入一个volatitle变量并且线程B随后读取该变量时，在写入volatitle变量之前对A可见的所有变量的值，在B读取了volatitle变量后，对B也是可见的。因此，从内存可见性的角度来看，写入volatitle变量相当于退出同步块，而读取volatile变量就相当于进入同步代码块。然而，我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。
> **仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方法包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如：初始化或关闭）**

> **volatile语义并不足以确保递增操作(count++)的原子性。**
**加锁机制既可以保证可见性又可以确保原子性，而volatile变量只能确保可见性**

&emsp;&emsp;当且仅当满足一下所有条件时，才应该使用volatile变量：
* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
* 该变量不会与其他变量一起纳入不变性条件中。
* 在访问变量时不需要加锁。

## 2. 发布与逸出
&emsp;&emsp;**"发布(Publish)"一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。**
&emsp;&emsp;**当某个不应该发布的对象被发布时，这种情况就被称为逸出(Escape)。**
 ```java
@UnThreadSafe
public class UnsafePublish {

    private String[] states = {"a","b","c"};

    /**
     * 通过public级别修饰的方法，变相的将类的私域发布到外部，任何外部线程都可以访问、修改该域。
     * 这样是不安全的，因为我们无法检查其他线程是否会修改这个域导致错误。
     * @return
     */
    public String[] getStates(){
        return states;
    }

    public static void main(String[] args) {
        UnsafePublish unsafePublish = new UnsafePublish();
        unsafePublish.getStates()[0] = "d";
    }
}
 ```
 