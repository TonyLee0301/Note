# 5 基础构建模块
## 5.1 同步容器类
&emsp;&emsp;同步容器类包括Vector和Hashtable，此外还包括一些功能类似的类，这些同步的封装器类由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式：降它们封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能够访问容器的状态。
### 5.1.1 同步容器类的问题
&emsp;&emsp;在遍历容器过程中，有对容器大小进行操作，那么就会出现ArrayIndexOutOfBoundsException这样的操作
### 5.1.2 迭代器与ConcurrentModificationException
&emsp;&emsp;for-each循环语法其实页是对容器类进行了迭代的标准方式都是使用Iterator。在设计同步容器类的迭代器时，并没有考虑到并发修改的问题，并且它们表现出的行为是“及时失败”（fail-fast）的。这以为着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException。
### 5.1.3 隐藏迭代器
&emsp;&emsp;例如容器的toString方法。如果在调用toString方法的同时，容器被修改，那么也有可能抛出ConcurrentModificationException。容器的HasCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样的containsAll、removeAll和retainAll等方法，已经把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的操作都可能抛出ConcurrentModificationException。

>正如封装对象的状态有助于维持不变形条件一样，封装对象的同步机制同样有助于确保实施同步策略

## 5.2 并发容器
并发容器是针对多个线程并发访问设计的。
> 通过并发容器来代替同步容器，可以极大的提供伸缩性并降低风险。

## 5.3 阻塞队列和生产者 - 消费者模式
> 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

### 5.3.1 串行线程封闭
&emsp;&emsp;对于可变对象，生产者 —— 消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来“转移”所有权。在转移所有权后，也只有另一个线程能够获取这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对新的所有者来说是可见的，并且由于最初的所有者不会再访问它，因此对象将封闭在新的线程中。新的所有者线程可以对该对象做任意修改，因为它具有独占的访问权。
&emsp;&emsp;线程池利用了串行线程封闭，将对象“借给”一个请求线程。只要对象池包含足够的内存同步来安全地发布池中对象，并且只要克服代码本身不会发布池中的对象，或者在将对象返回给对象池后就不再使用它，那么久可以安全地在线程之间传递所有权。
