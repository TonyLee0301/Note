# 5 基础构建模块
## 5.1 同步容器类
&emsp;&emsp;同步容器类包括Vector和Hashtable，此外还包括一些功能类似的类，这些同步的封装器类由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式：降它们封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能够访问容器的状态。
### 5.1.1 同步容器类的问题
&emsp;&emsp;在遍历容器过程中，有对容器大小进行操作，那么就会出现ArrayIndexOutOfBoundsException这样的操作
### 5.1.2 迭代器与ConcurrentModificationException
&emsp;&emsp;for-each循环语法其实页是对容器类进行了迭代的标准方式都是使用Iterator。在设计同步容器类的迭代器时，并没有考虑到并发修改的问题，并且它们表现出的行为是“及时失败”（fail-fast）的。这以为着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException。
### 5.1.3 隐藏迭代器
&emsp;&emsp;例如容器的toString方法。如果在调用toString方法的同时，容器被修改，那么也有可能抛出ConcurrentModificationException。容器的HasCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样的containsAll、removeAll和retainAll等方法，已经把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的操作都可能抛出ConcurrentModificationException。

>正如封装对象的状态有助于维持不变形条件一样，封装对象的同步机制同样有助于确保实施同步策略

## 5.2 并发容器
并发容器是针对多个线程并发访问设计的。
> 通过并发容器来代替同步容器，可以极大的提供伸缩性并降低风险。

## 5.3 阻塞队列和生产者 - 消费者模式
> 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。