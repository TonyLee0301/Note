
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [10 事务](#10-事务)
  - [10.1 JDBC 方式下使用示例](#101-jdbc-方式下使用示例)
- [10.2 事务自定义标签](#102-事务自定义标签)
    - [10.2.1 注册 InfrastructureAdvisorAutoProxyCreator](#1021-注册-infrastructureadvisorautoproxycreator)
    - [10.2.2 获取对应 class/method 的增强器](#1022-获取对应-classmethod-的增强器)
      - [1. 寻找候选增强器](#1-寻找候选增强器)
      - [2. 候选增强器中寻找到匹配项](#2-候选增强器中寻找到匹配项)
      - [3. 提取事务标签](#3-提取事务标签)

<!-- /code_chunk_output -->

# 10 事务
&emsp;&emsp;Spring声明式事务让我们从复杂的事务处理中得到解脱，使我们再也不需要去处理获得连接、 关闭连接 、 事务提交和回滚等操作，再也不需要在与事务相关的方法中处理大量的try...catch...finaly代码。 Spring 中事务的使用虽然已经相对简单得多，但是，还是有很多的使用及配置规则， 有兴趣的读者可以自己查阅相关资料进行深入研究，这里只列举出最常用的使用方法。

## 10.1 JDBC 方式下使用示例
&emsp;&emsp;前面的创建实体类，Mapper封装就不赘述了。字节看下如何开启事务吧。
 ```java
 @Transactional(propagation=Propagation.REQUIRED)
 public interface UserService{
     public void save(User user) throws Exception;
 }
 ```
 ```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd">
    <!-- 其他配置省略 -->
    <tx:annotation-driven transaction-manager="transactionManager" />
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
</beans>
 ```
&emsp;&emsp;**默认情况下Spring中的事务支只对RuntimeException方法进行回滚，所以，如果默认情况下将 Runtime Exception 替换成很普通的Exception不会产生回滚效果**

# 10.2 事务自定义标签
&emsp;&emsp;对于 Spring 中事务功能的代码分析，我们首先从配置文件开始入手，在配置文件中由这么一个配置:<tx:annotation-driven />。可以说此配置是事务的开关，如果没有此处配置，那么 Spring 中将不会存在事务的功能。那么我们就从这个配置开始分析。
&emsp;&emsp;根据之前的分析，我们可以判读啊，这是一个自定义标签，而在自定义标签的解析过程中一定是做了一些辅助操作，于是我们从自定义标签入手进行分析。
&emsp;&emsp;找到 TxNamespaceHandler 中的 init 方法中：
 ```java
    @Override
	public void init() {
		registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
		registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
	}
 ```
&emsp;&emsp;根据自定义标签的使用规则以及上面的代码，可以知道，在遇到诸如<tx:annotation-driven/> 为开头的配置，Spring 都会使用 AnnotationDrivenBeanDefinitionParser 类的 parse 方法进行解析。
 ```java
    @Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		registerTransactionalEventListenerFactory(parserContext);
		String mode = element.getAttribute("mode");
		if ("aspectj".equals(mode)) {
			// mode="aspectj"
			registerTransactionAspect(element, parserContext);
			if (ClassUtils.isPresent("javax.transaction.Transactional", getClass().getClassLoader())) {
				registerJtaTransactionAspect(element, parserContext);
			}
		}
		else {
			// mode="proxy"
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
		}
		return null;
	}
 ```
&emsp;&emsp;在解析中存在对 mode 属性的判断，根据代码，如果我们需要使用 AspectJ 的方式进行事务切入 （Spring 中的事务是以 AOP 为基础），那么可以使用这样的配置：
 ```xml
 <tx:annotation-driven transaction-manager="transactionManager" mode="aspectj">
 ```
### 10.2.1 注册 InfrastructureAdvisorAutoProxyCreator
&emsp;&emsp;我们以默认配置为例子进行分析，进入 AopAutoProxyConfigurer 类的 configureAutoProxyCreator：
 ```java
    public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

        String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
        if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
            Object eleSource = parserContext.extractSource(element);

            // Create the TransactionAttributeSource definition.
            // 创建 TransactionAttributeSource 的 bean
            RootBeanDefinition sourceDef = new RootBeanDefinition(
                    "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
            sourceDef.setSource(eleSource);
            sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            // 注册 bean，并使用 Spring 中的定义规则生成 beanname
            String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);

            // Create the TransactionInterceptor definition.
            // 创建 TransactionInterceptor 的 bean 定义
            RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
            interceptorDef.setSource(eleSource);
            interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            registerTransactionManager(element, interceptorDef);
            interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
            // 注册 bean，并使用 spring 中的定义规则生成 beanname
            String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

            // Create the TransactionAttributeSourceAdvisor definition.
            // 创建 TransactionAttributeSourceAdvisor 的 bean
            RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
            advisorDef.setSource(eleSource);
            advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            //将 sourceName 的 bean 注入到 advisorDef 的 transactionAttributeSource 属性中
            advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
            //将 interceptorName 的 bean 注入 advisorDef 的 adviceBeanName 属性中
            advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
            if (element.hasAttribute("order")) {
                advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
            }
            parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

            //创建 CompositeComponentDefinition
            CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
            compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
            compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
            compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
            parserContext.registerComponent(compositeDef);
        }
    }
 ```
&emsp;&emsp;上面的代码注册了代理类以及3个bean，这3个ben支撑了整个的事务功能，那么这3个bean是怎么组织起来的呢？
&emsp;&emsp;首先，其中的两个bean被注册到了一个名为 advisorDef 的 bean 中， advisorDef 使用 BeanFactoryTransactionAttributeSourceAdvisor 作为其 class 属性。也就是收 BeanFactoryTransactionAttributeSourceAdvisor 代表着当前bean。
&emsp;&emsp;我们先来看configureAutoProxyCreator中一句很简单却很重要的代码：
 ```java
    AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

    public static void registerAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

        BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(
                parserContext.getRegistry(), parserContext.extractSource(sourceElement));
        useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
        registerComponentIfNecessary(beanDefinition, parserContext);
    }

    @Nullable
    public static BeanDefinition registerAutoProxyCreatorIfNecessary(
            BeanDefinitionRegistry registry, @Nullable Object source) {

        return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
    }
 ```
&emsp;&emsp;对于解析来的代码流程 AOP 中已经有说分析，上面的两个函数主要目的是注册了 InfrastructureAdvisorAutoProxyCreator 类型的bean，那么注册这个类的目的是什么呢？
![](resources/InfrastructureAdvisorAutoProxyCreator.png)
&emsp;&emsp;从上面的层次结构中可以看到，InfrastructureAdvisorAutoProxyCreator 间接实现了 SmartInstantiationAwareBeanPostProcessor ， 而 SmartInstantiationAwareBeanPostProcessor 又继承自 InstantiationAwareBeanPostProcessor ， 也就是说在 Spring 中，所有bean 实例化时Spring都会保证调用其 postProcessAfterInitialization 方法，其实现时在弗雷 AbstractAutoProxyCreator 类中实现。
&emsp;&emsp;当实例化一个bean时，便会调用此方法：
 ```java
    /**
	 * Create a proxy with the configured interceptors if the bean is
	 * identified as one to proxy by the subclass.
	 * @see #getAdvicesAndAdvisorsForBean
	 */
	@Override
	public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
		if (bean != null) {
			//根据给定的bean的class 和name 构建出一个key，格式：beanClassName_beanName
			Object cacheKey = getCacheKey(bean.getClass(), beanName);
			if (this.earlyProxyReferences.remove(cacheKey) != bean) {
				//如果它适合被代理，这需要封装状指定bean
				return wrapIfNecessary(bean, beanName, cacheKey);
			}
		}
		return bean;
	}
 ```
&emsp;&emsp;这里的实现的主要目的是对指定 bean 进行封装，当然首先要确定是否需要封装，检测及封装工作都委托给了 wrapIfNeccessary 函数进行。
 ```java
 /**
	 * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.
	 * @param bean the raw bean instance
	 * @param beanName the name of the bean
	 * @param cacheKey the cache key for metadata access
	 * @return a proxy wrapping the bean, or the raw bean instance as-is
	 */
	protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
		//判断该beanName是否已经处理过
		if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {
			return bean;
		}
		//无需增强
		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
			return bean;
		}
		//判断bean类是否代表一个基础设施，或者配置了bean不需要自动代理
		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
			this.advisedBeans.put(cacheKey, Boolean.FALSE);
			return bean;
		}

		// Create proxy if we have advice.
		// 获取增强的方法
		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
			this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建代理
			Object proxy = createProxy(
					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}

		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}
 ```
&emsp;&emsp;wrapIfNecessary 函数功能实现起来很复杂，但逻辑上理解起来还是相对简单的，在 wrapIfNecessary 函数中主要的工作如下。
* 找出指定 bean 对应的增强器。
* 根据找出的增强器创建代理。
&emsp;&emsp;听起来似乎简单的逻辑，Spring中有做了哪些复杂的工作呢？ 对于创建代理的部分。

### 10.2.2 获取对应 class/method 的增强器
&emsp;&emsp;获取指定 bean 对应的增强器，其中包含两个关键字：增强器与对应。也就是说在 getAdvicesAndAdvisorsForBean 函数中，不但要找出增强器，而且还要判断增强器是否满足要求。
 ```java
    @Override
	@Nullable
	protected Object[] getAdvicesAndAdvisorsForBean(
			Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {

		List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
		if (advisors.isEmpty()) {
			return DO_NOT_PROXY;
		}
		return advisors.toArray();
	}
    protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
		List<Advisor> candidateAdvisors = findCandidateAdvisors();
		List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
		extendAdvisors(eligibleAdvisors);
		if (!eligibleAdvisors.isEmpty()) {
			eligibleAdvisors = sortAdvisors(eligibleAdvisors);
		}
		return eligibleAdvisors;
	}
 ```
&emsp;&emsp;上面的函数，Spring 又将任务进行了拆分，分成了获取所有增强器与增强器是否匹配两个功能点。
#### 1. 寻找候选增强器
&emsp;&emsp;在 findCandidateAdvisors 函数中完成的就是获取增强器的功能。
 ```java
    /**
	 * Find all candidate Advisors to use in auto-proxying.
	 * @return the List of candidate Advisors
	 */
	protected List<Advisor> findCandidateAdvisors() {
		Assert.state(this.advisorRetrievalHelper != null, "No BeanFactoryAdvisorRetrievalHelper available");
		return this.advisorRetrievalHelper.findAdvisorBeans();
	}

    public List<Advisor> findAdvisorBeans() {
		// Determine list of advisor bean names, if not cached already.
		String[] advisorNames = this.cachedAdvisorBeanNames;
		if (advisorNames == null) {
			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the auto-proxy creator apply to them!
			advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
					this.beanFactory, Advisor.class, true, false);
			this.cachedAdvisorBeanNames = advisorNames;
		}
		if (advisorNames.length == 0) {
			return new ArrayList<>();
		}

		List<Advisor> advisors = new ArrayList<>();
		for (String name : advisorNames) {
			if (isEligibleBean(name)) {
				if (this.beanFactory.isCurrentlyInCreation(name)) {
					if (logger.isTraceEnabled()) {
						logger.trace("Skipping currently created advisor '" + name + "'");
					}
				}
				else {
					try {
						advisors.add(this.beanFactory.getBean(name, Advisor.class));
					}
					catch (BeanCreationException ex) {
						Throwable rootCause = ex.getMostSpecificCause();
						if (rootCause instanceof BeanCurrentlyInCreationException) {
							BeanCreationException bce = (BeanCreationException) rootCause;
							String bceBeanName = bce.getBeanName();
							if (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {
								if (logger.isTraceEnabled()) {
									logger.trace("Skipping advisor '" + name +
											"' with dependency on currently created bean: " + ex.getMessage());
								}
								// Ignore: indicates a reference back to the bean we're trying to advise.
								// We want to find advisors other than the currently created bean itself.
								continue;
							}
						}
						throw ex;
					}
				}
			}
		}
		return advisors;
	}
 ```
&emsp;&emsp;上面的函数，通过 BeanFactoryUtils 类提供的工具方法获取所有对应 Advisor.class 的类，获取办法无非是使用 ListableBeanFactory 中提供的方法,当我们知道增强器在容器中的beanName时，获取增强器已经不是问题了，在 BeanFactory中提供了这样的方法，可以帮我们快速定位到对应的bean实例。
 ```java
 <T> T getBean(String name, Class<T> requiredType) throws BeanExcetpion;
 ```
&emsp;&emsp;我们再来看看之前在解析自定义标签时，曾注册了一个类型为 BeanFactoryTransactionAttributeSourceAdvisor 的 bean，而在此 bean 中我们又注入了另外两个 Bean， 那么此时这个 Bean 就会被开始被使用了。因为 BeanFactorytransactionAttributeSourceAdvisor 同样实现了 Advisor 接口，那么在获取所有增强器时自然也会将此bean提取出来，并随着其他增强器一起在后续的步骤中被织入代理。
#### 2. 候选增强器中寻找到匹配项
&emsp;&emsp;当找出对应的增强器后，接下来的任务就是看这些增强器是否与对应的 class 匹配了，当然不只是 class， class 内部的方法如果匹配也可以通过验证。
 ```java
    public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
		if (candidateAdvisors.isEmpty()) {
			return candidateAdvisors;
		}
		List<Advisor> eligibleAdvisors = new ArrayList<>();
		//首先处理 引介 增强
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
				eligibleAdvisors.add(candidate);
			}
		}
		boolean hasIntroductions = !eligibleAdvisors.isEmpty();
		for (Advisor candidate : candidateAdvisors) {
			//引介增强已处理
			if (candidate instanceof IntroductionAdvisor) {
				// already processed
				continue;
			}
			//对于普通bean的处理
			if (canApply(candidate, clazz, hasIntroductions)) {
				eligibleAdvisors.add(candidate);
			}
		}
		return eligibleAdvisors;
	}

    public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
		if (advisor instanceof IntroductionAdvisor) {
			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
		}
		else if (advisor instanceof PointcutAdvisor) {
			PointcutAdvisor pca = (PointcutAdvisor) advisor;
			return canApply(pca.getPointcut(), targetClass, hasIntroductions);
		}
		else {
			// It doesn't have a pointcut so we assume it applies.
			return true;
		}
	}
 ```
&emsp;&emsp;我们之前查找出来的类型 为 BeanFactoryTransactionAttributeSourceAdvisor 的bean实例，而通过类的层次结构，我们又知道 BeanFactoryTransactionAttributeSourceAdvisor 间接实现了 PointcutAdvisor。因此，在 canApply 函数中的第二个if判断时就会通过判断，会将 BeanFactoryTransactionAttributeSourceAdvisor 中的 getPointcut() 返回值作为参数继续调用 canApply 方法，而 getPoint() 方法返回的就是  TransactionAttributeSourcePointcut 类型的实例。对于 transactionAttributeSource 这个属性，同样是在自定义标签时注入进去的。
> BeanFactoryTransactionAttributeSourceAdvisor
 ```java
    private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
		@Override
		@Nullable
		protected TransactionAttributeSource getTransactionAttributeSource() {
			return transactionAttributeSource;
		}
	};

    @Override
	public Pointcut getPointcut() {
		return this.pointcut;
	}
 ```
&emsp;&emsp;那么,使用 TransactionAttributeSourcePointcut 类型的实例作为函数参数继续跟踪 canApply。
 ```java
    public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
		Assert.notNull(pc, "Pointcut must not be null");
		//首先还是通过 classFilter 匹配 当前切点是否 目标类代理目标类
		if (!pc.getClassFilter().matches(targetClass)) {
			return false;
		}

		// 返回 Pointcut 的 methodMatcher
		MethodMatcher methodMatcher = pc.getMethodMatcher();
		//如果methodMatcher 如果是 TrueMethodMatcher
		//就代表我们需要匹配所有方法不需要迭代方法
		if (methodMatcher == MethodMatcher.TRUE) {
			// No need to iterate the methods if we're matching any method anyway...
			return true;
		}

		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
		}

		Set<Class<?>> classes = new LinkedHashSet<>();
		if (!Proxy.isProxyClass(targetClass)) {
			classes.add(ClassUtils.getUserClass(targetClass));
		}
		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

		for (Class<?> clazz : classes) {
			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
			for (Method method : methods) {
				if (introductionAwareMethodMatcher != null ?
						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
						methodMatcher.matches(method, targetClass)) {
					return true;
				}
			}
		}

		return false;
	}
 ```
&emsp;&emsp;通过上面函数大致可以理清大体脉络，首先获取对应类的所有接口并连同类本身一起遍历，遍历过程中又对类中的方法再次遍历，一旦匹配成功便认为这个类适合当前增强器。
&emsp;&emsp;对于事务的配置不仅仅局限于函数上配置，我们都知道，在类或接口上的配置可以延续到类中的每个函数，那么，如果针对每个函数进行检测，在类本身上配置的事务属性岂不是检测不到了吗？带着这个疑问，我们继续探求 matcher 方法。
&emsp;&emsp;做匹配的时候 methodMatcher.matches(method,targetClass)会使用 TransactionAttributeSourcePointcut 类的 matches 方法。
> TransactionAttributeSourcePointcut
 ```java
    @Override
	public boolean matches(Method method, Class<?> targetClass) {
		TransactionAttributeSource tas = getTransactionAttributeSource();
		return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
	}
 ```
&emsp;&emsp;此时的tas 表示的是 AnnotationTransactionAttributeSource 类型，而 AnnotationTransactionAttributeSource 类型的 getTransactionAttribute 方法如下：
 ```java
    public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		// First, see if we have a cached value.
		Object cacheKey = getCacheKey(method, targetClass);
		TransactionAttribute cached = this.attributeCache.get(cacheKey);
		if (cached != null) {
			// Value will either be canonical value indicating there is no transaction attribute,
			// or an actual transaction attribute.
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return cached;
			}
		}
		else {
			// We need to work it out.
			// 提取事务标签
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// Put it in the cache.
			if (txAttr == null) {
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
				//获取方法的全限定名  class.method
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isTraceEnabled()) {
					logger.trace("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr);
				}
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}
 ```
&emsp;&emsp;在 getTransactionAttribute 函数中并没有早到我们想要的代码，这里是指常规的一贯的套路，尝试从缓存加载，如果对应信息没有被缓存的话，工作又委托给了 computeTransactionAttribute 函数，在 computeTransactionAttribute 函数中我们就可以看到事务标签的提取过程。
#### 3. 提取事务标签
 ```java
    @Nullable
	protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		// Don't allow no-public methods as required.
		if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		// The method may be on an interface, but we need attributes from the target class.
		// If the target class is null, the method will be unchanged.
		// 获取目标类上的方法，specificMethod 实现类上的方法。如果targetClass已经被aspectj创建了代理类，那么取被代理类
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		// First try is the method in the target class.
		// 第一步，现在目标类上获取 指定的方法上的事务声明
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		// Second try is the transaction attribute on the target class.
		// 第二步获取所在类中是否存在事务声明
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

		// 如果存在接口，这到接口中去寻找
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			//查找接口方法
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			//查找接口
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}

		return null;
	}
 ```
&emsp;&emsp;对于事务属性的获取规则相信大家都已经很清楚，如果方法中存在事务属性，则使用方法上的属性，否则使用方法所在的类上的属性，如果方法所在类的属性上还是没有搜寻到对应的事务属性，那么再搜寻接口中的方法，再没有的话，最后尝试搜寻接口的类上面的声明。对于函数 computeTransactionAttribute 中的逻辑与我们所认识的规则并无差别，但是上面函数中并没有真正的去做搜寻事务属性的逻辑，而是搭建了个执行框架，将搜寻事务属性的任务委托给了 findTransactionAttribute 方法去执行。
 ```java
    @Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Class<?> clazz) {
		return determineTransactionAttribute(clazz);
	}

    @Nullable
	protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) {
		for (TransactionAnnotationParser parser : this.annotationParsers) {
			TransactionAttribute attr = parser.parseTransactionAnnotation(element);
			if (attr != null) {
				return attr;
			}
		}
		return null;
	}
 ```
&emsp;&emsp;this.annotationParsers 是 AnnotationTransactionAttributeSource 初始化的时候初始化的，其中的值被加入了 SpringTransactionAnnotationParser ，也即是当前进行属性获取时候其实使用 SpringTransactionAnnotationParser 类的 parseTransactionAnnotation 方法进行解析的。同时还根据环境加入了 JtaTransactionAnnotationParser 和 Ejb3TransactionAnnotationParser 的支持，分别是jdk支持的transaction注解和ejb支持的transaction注解。
&emsp;&emsp;后面的解析，就不详细讲解了，可以分别看看几个实现 TransactionAnnotationParser 的实现类的属性解析。
&emsp;&emsp;现在我们终于完成了事务标签的解析。到现在可能很多人已经晕了，忘记了我们最初到底是要看什么的。其实我们就是找出某个增强器是否适合对应的类，而是否匹配的关键则在于是否从指定的类或类中的方法找到对应的事务属性。
&emsp;&emsp;至此，事务功能的初始化工作便结束了，当判断某个 bean 适用于事务增强器时，也就是适用于增强器 BeanFactoryTransactionAttributeSourceAdvisor 的类，其作为 Advisor 实现类，又因为在解析事务定义标签时我们把 TransactionInterceptor 类型的 bean 注入到了 BeanFactoryTransactionAttributeSourceAdvisor 中，所以，在调用事务增强器的代理类时会首先执行 TransactionInterceptor 进行增强，同时，也就是 TransactionInterceptor 类中的 invoke 方法中完成整个事务逻辑。

## 10.3 事务增强器
&emsp;&emsp; TransactionInterceptor 支撑着整个事务功能的架构，逻辑还是相对复杂的，现在我们就来分析此拦截器是如何实现事务特性的。 TransactionInterceptor 类继承至 MethodInterceptor ，所以调用该类是从 invoke 方法开始的，首先看下这个方法：
 ```java
 	@Override
	@Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {
		// Work out the target class: may be {@code null}.
		// The TransactionAttributeSource should be passed the target class
		// as well as the method, which may be from an interface.
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

		// Adapt to TransactionAspectSupport's invokeWithinTransaction...
		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
	}

	protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
			final InvocationCallback invocation) throws Throwable {

		// If the transaction attribute is null, the method is non-transactional.
		// 获取事务属性源
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 获取该事务和目标类的事务属性
		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
		// 获取 beanFactory 中的 transactionManager
		final TransactionManager tm = determineTransactionManager(txAttr);

		if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
			ReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> {
				if (KotlinDetector.isKotlinType(method.getDeclaringClass()) && KotlinDelegate.isSuspend(method)) {
					throw new TransactionUsageException(
							"Unsupported annotated transaction on suspending function detected: " + method +
							". Use TransactionalOperator.transactional extensions instead.");
				}
				ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(method.getReturnType());
				if (adapter == null) {
					throw new IllegalStateException("Cannot apply reactive transaction to non-reactive return type: " +
							method.getReturnType());
				}
				return new ReactiveTransactionSupport(adapter);
			});
			return txSupport.invokeWithinTransaction(
					method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);
		}

		PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
		//构造方法的唯一标示 (类.方法，如 UserServiceImpl.save)
		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

		//声明式事务处理
		if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
			// Standard transaction demarcation with getTransaction and commit/rollback calls.
			// 创建 TransactionInfo
			TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);

			Object retVal;
			try {
				// This is an around advice: Invoke the next interceptor in the chain.
				// This will normally result in a target object being invoked.
				// 执行增强方法
				retVal = invocation.proceedWithInvocation();
			}
			catch (Throwable ex) {
				// target invocation exception
				//异常回滚
				completeTransactionAfterThrowing(txInfo, ex);
				throw ex;
			}
			finally {
				//清除信息
				cleanupTransactionInfo(txInfo);
			}

			if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {
				// Set rollback-only in case of Vavr failure matching our rollback rules...
				TransactionStatus status = txInfo.getTransactionStatus();
				if (status != null && txAttr != null) {
					retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
				}
			}

			//提交事务
			commitTransactionAfterReturning(txInfo);
			return retVal;
		}

		else {
			final ThrowableHolder throwableHolder = new ThrowableHolder();

			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
			// 编程式事务处理
			try {
				Object result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -> {
					TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);
					try {
						Object retVal = invocation.proceedWithInvocation();
						if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {
							// Set rollback-only in case of Vavr failure matching our rollback rules...
							retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
						}
						return retVal;
					}
					catch (Throwable ex) {
						if (txAttr.rollbackOn(ex)) {
							// A RuntimeException: will lead to a rollback.
							if (ex instanceof RuntimeException) {
								throw (RuntimeException) ex;
							}
							else {
								throw new ThrowableHolderException(ex);
							}
						}
						else {
							// A normal return value: will lead to a commit.
							throwableHolder.throwable = ex;
							return null;
						}
					}
					finally {
						cleanupTransactionInfo(txInfo);
					}
				});

				// Check result state: It might indicate a Throwable to rethrow.
				if (throwableHolder.throwable != null) {
					throw throwableHolder.throwable;
				}
				return result;
			}
			catch (ThrowableHolderException ex) {
				throw ex.getCause();
			}
			catch (TransactionSystemException ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
					ex2.initApplicationException(throwableHolder.throwable);
				}
				throw ex2;
			}
			catch (Throwable ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
				}
				throw ex2;
			}
		}
	}
 ```
&emsp;&emsp;在上面的函数中，我们尝试整理下事务处理的脉络，在 Spring 中支持两种事务处理的方式，分别是声明式事务处理与编程式事务处理，两者相对于开发人员来将差别很大，但是对于 Spring 中的实现来将，大同小异。在invoke中我们可以看到这两种方式的实现。考虑到事务的应用声明式事务处理使用起来方便，也相对流行些，我们就以此种方法进行分析。对于声明式事务处理主要有以下几个步骤。
1. 获取事务的属性。
&emsp;&emsp;对于事务来说，最基础或者说最首要的工作便是获取事务属性了，这是支撑整个事务功能的基石，如果没有事务属性，其他功能也无从谈起，在分析事务准备阶段时我们已经分析了事务属性提取的功能，大家应该有所了解。
1. 加载配置中的TransactionManager。
1. 不同的事务处理方式使用不同的逻辑。
&emsp;&emsp;对于声明式事务的处理与编程式事务的处理，低一点区别在于事务属性上，因为编程式的事务处理是不需要有事务属性的，第二点区别就是在 TransactionManager 上，CallPreferringPlatformTransactionManager 实现 PlatformTransactionManager 接口，暴露出一个方法用于执行事务处理中的回调。所以，这两种方式都可以用作事务处理方式的判断。
1. 在目标方法执行前获取事务并手机事务信息。
&emsp;&emsp;事务信息与事务属性并不相同，也就是 TransactionInfo 与 TransactionAttribute 并不相同， TransactionInfo 中包含了 TransactionAttribute 信息，但是，除了 TransactionAttribute 外还有其他事务信息，例如 PlatformTransactionManager 以及 TransactionStatus 相关信息。
1. 执行目标方法。
1. 一旦出现异常，尝试异常处理。
&emsp;&emsp;并不是所有异常，Spring 都会将其回滚，默认只对 RuntimeException 回滚。
1. 提交事务前的事务信息清除。
1. 提交事务。

### 10.3.1 创建事务
 ```java
 	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {

		// If no name specified, apply method identification as transaction name.
		// 如果没有名称指定则使用方法唯一标识，并使用 DelegatingTransactionAttribute 封装 txAttr
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				//获取 TransactionStatus
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		//根据指定的属性与status准备一个 TransactionInfo
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}
 ```
&emsp;&emsp;对于 createTransactionIfNecessary 函数主要做了这样几件事情。
1. 使用 DelegatingTransactionAttribute 封装传入 的 TransactionAttribute 实例。
&emsp;&emsp;对于传入 TransactionAtribute 类型的参数 txAttr，当前的实际类型是 RuleBasedTransactionAttribute， 是由获取事务属性时生成，主要用于数据承载，而这里之所以使用 DelegatingTransactionAttribute 进行封装，当然是提供了更多的功能。
1. 获取事务。
&emsp;&emsp;事务处理当然以事务为核心，那么获取事务就是最重要的事情。
1. 构建事务信息
&emsp;&emsp;根据之前几个步骤获取的信息构建 TransactionInfo 并返回。

#### 1. 获取事务
