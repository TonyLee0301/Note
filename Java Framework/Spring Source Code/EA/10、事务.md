
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [10 事务](#10-事务)
  - [10.1 JDBC 方式下使用示例](#101-jdbc-方式下使用示例)
- [10.2 事务自定义标签](#102-事务自定义标签)
    - [10.2.1 注册 InfrastructureAdvisorAutoProxyCreator](#1021-注册-infrastructureadvisorautoproxycreator)
    - [10.2.2 获取对应 class/method 的增强器](#1022-获取对应-classmethod-的增强器)
      - [1. 寻找候选增强器](#1-寻找候选增强器)
      - [2. 候选增强器中寻找到匹配项](#2-候选增强器中寻找到匹配项)
      - [3. 提取事务标签](#3-提取事务标签)
  - [10.3 事务增强器](#103-事务增强器)
    - [10.3.1 创建事务](#1031-创建事务)
      - [1. 获取事务](#1-获取事务)
      - [2. 处理已存在的事务](#2-处理已存在的事务)
    - [10.3.2 回滚处理](#1032-回滚处理)

<!-- /code_chunk_output -->

# 10 事务
&emsp;&emsp;Spring声明式事务让我们从复杂的事务处理中得到解脱，使我们再也不需要去处理获得连接、 关闭连接 、 事务提交和回滚等操作，再也不需要在与事务相关的方法中处理大量的try...catch...finaly代码。 Spring 中事务的使用虽然已经相对简单得多，但是，还是有很多的使用及配置规则， 有兴趣的读者可以自己查阅相关资料进行深入研究，这里只列举出最常用的使用方法。

## 10.1 JDBC 方式下使用示例
&emsp;&emsp;前面的创建实体类，Mapper封装就不赘述了。字节看下如何开启事务吧。
 ```java
 @Transactional(propagation=Propagation.REQUIRED)
 public interface UserService{
     public void save(User user) throws Exception;
 }
 ```
 ```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd">
    <!-- 其他配置省略 -->
    <tx:annotation-driven transaction-manager="transactionManager" />
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
</beans>
 ```
&emsp;&emsp;**默认情况下Spring中的事务支只对RuntimeException方法进行回滚，所以，如果默认情况下将 Runtime Exception 替换成很普通的Exception不会产生回滚效果**

# 10.2 事务自定义标签
&emsp;&emsp;对于 Spring 中事务功能的代码分析，我们首先从配置文件开始入手，在配置文件中由这么一个配置:<tx:annotation-driven />。可以说此配置是事务的开关，如果没有此处配置，那么 Spring 中将不会存在事务的功能。那么我们就从这个配置开始分析。
&emsp;&emsp;根据之前的分析，我们可以判读啊，这是一个自定义标签，而在自定义标签的解析过程中一定是做了一些辅助操作，于是我们从自定义标签入手进行分析。
&emsp;&emsp;找到 TxNamespaceHandler 中的 init 方法中：
 ```java
    @Override
	public void init() {
		registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
		registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
	}
 ```
&emsp;&emsp;根据自定义标签的使用规则以及上面的代码，可以知道，在遇到诸如<tx:annotation-driven/> 为开头的配置，Spring 都会使用 AnnotationDrivenBeanDefinitionParser 类的 parse 方法进行解析。
 ```java
    @Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		registerTransactionalEventListenerFactory(parserContext);
		String mode = element.getAttribute("mode");
		if ("aspectj".equals(mode)) {
			// mode="aspectj"
			registerTransactionAspect(element, parserContext);
			if (ClassUtils.isPresent("javax.transaction.Transactional", getClass().getClassLoader())) {
				registerJtaTransactionAspect(element, parserContext);
			}
		}
		else {
			// mode="proxy"
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
		}
		return null;
	}
 ```
&emsp;&emsp;在解析中存在对 mode 属性的判断，根据代码，如果我们需要使用 AspectJ 的方式进行事务切入 （Spring 中的事务是以 AOP 为基础），那么可以使用这样的配置：
 ```xml
 <tx:annotation-driven transaction-manager="transactionManager" mode="aspectj">
 ```
### 10.2.1 注册 InfrastructureAdvisorAutoProxyCreator
&emsp;&emsp;我们以默认配置为例子进行分析，进入 AopAutoProxyConfigurer 类的 configureAutoProxyCreator：
 ```java
    public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

        String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
        if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
            Object eleSource = parserContext.extractSource(element);

            // Create the TransactionAttributeSource definition.
            // 创建 TransactionAttributeSource 的 bean
            RootBeanDefinition sourceDef = new RootBeanDefinition(
                    "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
            sourceDef.setSource(eleSource);
            sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            // 注册 bean，并使用 Spring 中的定义规则生成 beanname
            String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);

            // Create the TransactionInterceptor definition.
            // 创建 TransactionInterceptor 的 bean 定义
            RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
            interceptorDef.setSource(eleSource);
            interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            registerTransactionManager(element, interceptorDef);
            interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
            // 注册 bean，并使用 spring 中的定义规则生成 beanname
            String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

            // Create the TransactionAttributeSourceAdvisor definition.
            // 创建 TransactionAttributeSourceAdvisor 的 bean
            RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
            advisorDef.setSource(eleSource);
            advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            //将 sourceName 的 bean 注入到 advisorDef 的 transactionAttributeSource 属性中
            advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
            //将 interceptorName 的 bean 注入 advisorDef 的 adviceBeanName 属性中
            advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
            if (element.hasAttribute("order")) {
                advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
            }
            parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

            //创建 CompositeComponentDefinition
            CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
            compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
            compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
            compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
            parserContext.registerComponent(compositeDef);
        }
    }
 ```
&emsp;&emsp;上面的代码注册了代理类以及3个bean，这3个ben支撑了整个的事务功能，那么这3个bean是怎么组织起来的呢？
&emsp;&emsp;首先，其中的两个bean被注册到了一个名为 advisorDef 的 bean 中， advisorDef 使用 BeanFactoryTransactionAttributeSourceAdvisor 作为其 class 属性。也就是说 BeanFactoryTransactionAttributeSourceAdvisor 代表着当前bean。
&emsp;&emsp;我们先来看configureAutoProxyCreator中一句很简单却很重要的代码：
 ```java
    AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

    public static void registerAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

        BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(
                parserContext.getRegistry(), parserContext.extractSource(sourceElement));
        useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
        registerComponentIfNecessary(beanDefinition, parserContext);
    }

    @Nullable
    public static BeanDefinition registerAutoProxyCreatorIfNecessary(
            BeanDefinitionRegistry registry, @Nullable Object source) {

        return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
    }
 ```
&emsp;&emsp;对于解析来的代码流程 AOP 中已经有说分析，上面的两个函数主要目的是注册了 InfrastructureAdvisorAutoProxyCreator 类型的bean，那么注册这个类的目的是什么呢？
![](resources/InfrastructureAdvisorAutoProxyCreator.png)
&emsp;&emsp;从上面的层次结构中可以看到，InfrastructureAdvisorAutoProxyCreator 间接实现了 SmartInstantiationAwareBeanPostProcessor ， 而 SmartInstantiationAwareBeanPostProcessor 又继承自 InstantiationAwareBeanPostProcessor ， 也就是说在 Spring 中，所有bean 实例化时Spring都会保证调用其 postProcessAfterInitialization 方法，其实现时在父类 AbstractAutoProxyCreator 类中实现。
&emsp;&emsp;当实例化一个bean时，便会调用此方法：
 ```java
    /**
	 * Create a proxy with the configured interceptors if the bean is
	 * identified as one to proxy by the subclass.
	 * @see #getAdvicesAndAdvisorsForBean
	 */
	@Override
	public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
		if (bean != null) {
			//根据给定的bean的class 和name 构建出一个key，格式：beanClassName_beanName
			Object cacheKey = getCacheKey(bean.getClass(), beanName);
			if (this.earlyProxyReferences.remove(cacheKey) != bean) {
				//如果它适合被代理，这需要封装状指定bean
				return wrapIfNecessary(bean, beanName, cacheKey);
			}
		}
		return bean;
	}
 ```
&emsp;&emsp;这里的实现的主要目的是对指定 bean 进行封装，当然首先要确定是否需要封装，检测及封装工作都委托给了 wrapIfNeccessary 函数进行。
 ```java
 /**
	 * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.
	 * @param bean the raw bean instance
	 * @param beanName the name of the bean
	 * @param cacheKey the cache key for metadata access
	 * @return a proxy wrapping the bean, or the raw bean instance as-is
	 */
	protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
		//判断该beanName是否已经处理过
		if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {
			return bean;
		}
		//无需增强
		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
			return bean;
		}
		//判断bean类是否代表一个基础设施，或者配置了bean不需要自动代理
		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
			this.advisedBeans.put(cacheKey, Boolean.FALSE);
			return bean;
		}

		// Create proxy if we have advice.
		// 获取增强的方法
		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
			this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建代理
			Object proxy = createProxy(
					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}

		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}
 ```
&emsp;&emsp;wrapIfNecessary 函数功能实现起来很复杂，但逻辑上理解起来还是相对简单的，在 wrapIfNecessary 函数中主要的工作如下。
* 找出指定 bean 对应的增强器。
* 根据找出的增强器创建代理。
&emsp;&emsp;听起来似乎简单的逻辑，Spring中有做了哪些复杂的工作呢？ 对于创建代理的部分。

### 10.2.2 获取对应 class/method 的增强器
&emsp;&emsp;获取指定 bean 对应的增强器，其中包含两个关键字：增强器与对应。也就是说在 getAdvicesAndAdvisorsForBean 函数中，不但要找出增强器，而且还要判断增强器是否满足要求。
 ```java
    @Override
	@Nullable
	protected Object[] getAdvicesAndAdvisorsForBean(
			Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {

		List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
		if (advisors.isEmpty()) {
			return DO_NOT_PROXY;
		}
		return advisors.toArray();
	}
    protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
		List<Advisor> candidateAdvisors = findCandidateAdvisors();
		List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
		extendAdvisors(eligibleAdvisors);
		if (!eligibleAdvisors.isEmpty()) {
			eligibleAdvisors = sortAdvisors(eligibleAdvisors);
		}
		return eligibleAdvisors;
	}
 ```
&emsp;&emsp;上面的函数，Spring 又将任务进行了拆分，分成了获取所有增强器与增强器是否匹配两个功能点。
#### 1. 寻找候选增强器
&emsp;&emsp;在 findCandidateAdvisors 函数中完成的就是获取增强器的功能。
 ```java
    /**
	 * Find all candidate Advisors to use in auto-proxying.
	 * @return the List of candidate Advisors
	 */
	protected List<Advisor> findCandidateAdvisors() {
		Assert.state(this.advisorRetrievalHelper != null, "No BeanFactoryAdvisorRetrievalHelper available");
		return this.advisorRetrievalHelper.findAdvisorBeans();
	}

    public List<Advisor> findAdvisorBeans() {
		// Determine list of advisor bean names, if not cached already.
		String[] advisorNames = this.cachedAdvisorBeanNames;
		if (advisorNames == null) {
			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the auto-proxy creator apply to them!
			advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
					this.beanFactory, Advisor.class, true, false);
			this.cachedAdvisorBeanNames = advisorNames;
		}
		if (advisorNames.length == 0) {
			return new ArrayList<>();
		}

		List<Advisor> advisors = new ArrayList<>();
		for (String name : advisorNames) {
			if (isEligibleBean(name)) {
				if (this.beanFactory.isCurrentlyInCreation(name)) {
					if (logger.isTraceEnabled()) {
						logger.trace("Skipping currently created advisor '" + name + "'");
					}
				}
				else {
					try {
						advisors.add(this.beanFactory.getBean(name, Advisor.class));
					}
					catch (BeanCreationException ex) {
						Throwable rootCause = ex.getMostSpecificCause();
						if (rootCause instanceof BeanCurrentlyInCreationException) {
							BeanCreationException bce = (BeanCreationException) rootCause;
							String bceBeanName = bce.getBeanName();
							if (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {
								if (logger.isTraceEnabled()) {
									logger.trace("Skipping advisor '" + name +
											"' with dependency on currently created bean: " + ex.getMessage());
								}
								// Ignore: indicates a reference back to the bean we're trying to advise.
								// We want to find advisors other than the currently created bean itself.
								continue;
							}
						}
						throw ex;
					}
				}
			}
		}
		return advisors;
	}
 ```
&emsp;&emsp;上面的函数，通过 BeanFactoryUtils 类提供的工具方法获取所有对应 Advisor.class 的类，获取办法无非是使用 ListableBeanFactory 中提供的方法,当我们知道增强器在容器中的beanName时，获取增强器已经不是问题了，在 BeanFactory中提供了这样的方法，可以帮我们快速定位到对应的bean实例。
 ```java
 <T> T getBean(String name, Class<T> requiredType) throws BeanExcetpion;
 ```
&emsp;&emsp;我们再来看看之前在解析自定义标签时，曾注册了一个类型为 BeanFactoryTransactionAttributeSourceAdvisor 的 bean，而在此 bean 中我们又注入了另外两个 Bean， 那么此时这个 Bean 就会被开始被使用了。因为 BeanFactorytransactionAttributeSourceAdvisor 同样实现了 Advisor 接口，那么在获取所有增强器时自然也会将此bean提取出来，并随着其他增强器一起在后续的步骤中被织入代理。
#### 2. 候选增强器中寻找到匹配项
&emsp;&emsp;当找出对应的增强器后，接下来的任务就是看这些增强器是否与对应的 class 匹配了，当然不只是 class， class 内部的方法如果匹配也可以通过验证。
 ```java
    public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
		if (candidateAdvisors.isEmpty()) {
			return candidateAdvisors;
		}
		List<Advisor> eligibleAdvisors = new ArrayList<>();
		//首先处理 引介 增强
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
				eligibleAdvisors.add(candidate);
			}
		}
		boolean hasIntroductions = !eligibleAdvisors.isEmpty();
		for (Advisor candidate : candidateAdvisors) {
			//引介增强已处理
			if (candidate instanceof IntroductionAdvisor) {
				// already processed
				continue;
			}
			//对于普通bean的处理
			if (canApply(candidate, clazz, hasIntroductions)) {
				eligibleAdvisors.add(candidate);
			}
		}
		return eligibleAdvisors;
	}

    public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
		if (advisor instanceof IntroductionAdvisor) {
			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
		}
		else if (advisor instanceof PointcutAdvisor) {
			PointcutAdvisor pca = (PointcutAdvisor) advisor;
			return canApply(pca.getPointcut(), targetClass, hasIntroductions);
		}
		else {
			// It doesn't have a pointcut so we assume it applies.
			return true;
		}
	}
 ```
&emsp;&emsp;我们之前查找出来的类型 为 BeanFactoryTransactionAttributeSourceAdvisor 的bean实例，而通过类的层次结构，我们又知道 BeanFactoryTransactionAttributeSourceAdvisor 间接实现了 PointcutAdvisor。因此，在 canApply 函数中的第二个if判断时就会通过判断，会将 BeanFactoryTransactionAttributeSourceAdvisor 中的 getPointcut() 返回值作为参数继续调用 canApply 方法，而 getPoint() 方法返回的就是  TransactionAttributeSourcePointcut 类型的实例。对于 transactionAttributeSource 这个属性，同样是在自定义标签时注入进去的。
> BeanFactoryTransactionAttributeSourceAdvisor
 ```java
    private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
		@Override
		@Nullable
		protected TransactionAttributeSource getTransactionAttributeSource() {
			return transactionAttributeSource;
		}
	};

    @Override
	public Pointcut getPointcut() {
		return this.pointcut;
	}
 ```
&emsp;&emsp;那么,使用 TransactionAttributeSourcePointcut 类型的实例作为函数参数继续跟踪 canApply。
 ```java
    public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
		Assert.notNull(pc, "Pointcut must not be null");
		//首先还是通过 classFilter 匹配 当前切点是否 目标类代理目标类
		if (!pc.getClassFilter().matches(targetClass)) {
			return false;
		}

		// 返回 Pointcut 的 methodMatcher
		MethodMatcher methodMatcher = pc.getMethodMatcher();
		//如果methodMatcher 如果是 TrueMethodMatcher
		//就代表我们需要匹配所有方法不需要迭代方法
		if (methodMatcher == MethodMatcher.TRUE) {
			// No need to iterate the methods if we're matching any method anyway...
			return true;
		}

		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
		}

		Set<Class<?>> classes = new LinkedHashSet<>();
		if (!Proxy.isProxyClass(targetClass)) {
			classes.add(ClassUtils.getUserClass(targetClass));
		}
		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

		for (Class<?> clazz : classes) {
			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
			for (Method method : methods) {
				if (introductionAwareMethodMatcher != null ?
						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
						methodMatcher.matches(method, targetClass)) {
					return true;
				}
			}
		}

		return false;
	}
 ```
&emsp;&emsp;通过上面函数大致可以理清大体脉络，首先获取对应类的所有接口并连同类本身一起遍历，遍历过程中又对类中的方法再次遍历，一旦匹配成功便认为这个类适合当前增强器。
&emsp;&emsp;对于事务的配置不仅仅局限于函数上配置，我们都知道，在类或接口上的配置可以延续到类中的每个函数，那么，如果针对每个函数进行检测，在类本身上配置的事务属性岂不是检测不到了吗？带着这个疑问，我们继续探求 matcher 方法。
&emsp;&emsp;做匹配的时候 methodMatcher.matches(method,targetClass)会使用 TransactionAttributeSourcePointcut 类的 matches 方法。
> TransactionAttributeSourcePointcut
 ```java
    @Override
	public boolean matches(Method method, Class<?> targetClass) {
		TransactionAttributeSource tas = getTransactionAttributeSource();
		return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
	}
 ```
&emsp;&emsp;此时的tas 表示的是 AnnotationTransactionAttributeSource 类型，而 AnnotationTransactionAttributeSource 类型的 getTransactionAttribute 方法如下：
 ```java
    public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		// First, see if we have a cached value.
		Object cacheKey = getCacheKey(method, targetClass);
		TransactionAttribute cached = this.attributeCache.get(cacheKey);
		if (cached != null) {
			// Value will either be canonical value indicating there is no transaction attribute,
			// or an actual transaction attribute.
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return cached;
			}
		}
		else {
			// We need to work it out.
			// 提取事务标签
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// Put it in the cache.
			if (txAttr == null) {
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
				//获取方法的全限定名  class.method
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isTraceEnabled()) {
					logger.trace("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr);
				}
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}
 ```
&emsp;&emsp;在 getTransactionAttribute 函数中并没有早到我们想要的代码，这里是指常规的一贯的套路，尝试从缓存加载，如果对应信息没有被缓存的话，工作又委托给了 computeTransactionAttribute 函数，在 computeTransactionAttribute 函数中我们就可以看到事务标签的提取过程。
#### 3. 提取事务标签
 ```java
    @Nullable
	protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		// Don't allow no-public methods as required.
		if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		// The method may be on an interface, but we need attributes from the target class.
		// If the target class is null, the method will be unchanged.
		// 获取目标类上的方法，specificMethod 实现类上的方法。如果targetClass已经被aspectj创建了代理类，那么取被代理类
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		// First try is the method in the target class.
		// 第一步，现在目标类上获取 指定的方法上的事务声明
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		// Second try is the transaction attribute on the target class.
		// 第二步获取所在类中是否存在事务声明
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

		// 如果存在接口，这到接口中去寻找
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			//查找接口方法
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			//查找接口
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}

		return null;
	}
 ```
&emsp;&emsp;对于事务属性的获取规则相信大家都已经很清楚，如果方法中存在事务属性，则使用方法上的属性，否则使用方法所在的类上的属性，如果方法所在类的属性上还是没有搜寻到对应的事务属性，那么再搜寻接口中的方法，再没有的话，最后尝试搜寻接口的类上面的声明。对于函数 computeTransactionAttribute 中的逻辑与我们所认识的规则并无差别，但是上面函数中并没有真正的去做搜寻事务属性的逻辑，而是搭建了个执行框架，将搜寻事务属性的任务委托给了 findTransactionAttribute 方法去执行。
 ```java
    @Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Class<?> clazz) {
		return determineTransactionAttribute(clazz);
	}

    @Nullable
	protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) {
		for (TransactionAnnotationParser parser : this.annotationParsers) {
			TransactionAttribute attr = parser.parseTransactionAnnotation(element);
			if (attr != null) {
				return attr;
			}
		}
		return null;
	}
 ```
&emsp;&emsp;this.annotationParsers 是 AnnotationTransactionAttributeSource 初始化的时候初始化的，其中的值被加入了 SpringTransactionAnnotationParser ，也即是当前进行属性获取时候其实使用 SpringTransactionAnnotationParser 类的 parseTransactionAnnotation 方法进行解析的。同时还根据环境加入了 JtaTransactionAnnotationParser 和 Ejb3TransactionAnnotationParser 的支持，分别是jdk支持的transaction注解和ejb支持的transaction注解。
&emsp;&emsp;后面的解析，就不详细讲解了，可以分别看看几个实现 TransactionAnnotationParser 的实现类的属性解析。
&emsp;&emsp;现在我们终于完成了事务标签的解析。到现在可能很多人已经晕了，忘记了我们最初到底是要看什么的。其实我们就是找出某个增强器是否适合对应的类，而是否匹配的关键则在于是否从指定的类或类中的方法找到对应的事务属性。
&emsp;&emsp;至此，事务功能的初始化工作便结束了，当判断某个 bean 适用于事务增强器时，也就是适用于增强器 BeanFactoryTransactionAttributeSourceAdvisor 的类，其作为 Advisor 实现类，又因为在解析事务定义标签时我们把 TransactionInterceptor 类型的 bean 注入到了 BeanFactoryTransactionAttributeSourceAdvisor 中，所以，在调用事务增强器的代理类时会首先执行 TransactionInterceptor 进行增强，同时，也就是 TransactionInterceptor 类中的 invoke 方法中完成整个事务逻辑。

## 10.3 事务增强器
&emsp;&emsp; TransactionInterceptor 支撑着整个事务功能的架构，逻辑还是相对复杂的，现在我们就来分析此拦截器是如何实现事务特性的。 TransactionInterceptor 类继承至 MethodInterceptor ，所以调用该类是从 invoke 方法开始的，首先看下这个方法：
 ```java
 	@Override
	@Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {
		// Work out the target class: may be {@code null}.
		// The TransactionAttributeSource should be passed the target class
		// as well as the method, which may be from an interface.
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

		// Adapt to TransactionAspectSupport's invokeWithinTransaction...
		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
	}

	protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
			final InvocationCallback invocation) throws Throwable {

		// If the transaction attribute is null, the method is non-transactional.
		// 获取事务属性源
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 获取该事务和目标类的事务属性
		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
		// 获取 beanFactory 中的 transactionManager
		final TransactionManager tm = determineTransactionManager(txAttr);

		if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
			ReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> {
				if (KotlinDetector.isKotlinType(method.getDeclaringClass()) && KotlinDelegate.isSuspend(method)) {
					throw new TransactionUsageException(
							"Unsupported annotated transaction on suspending function detected: " + method +
							". Use TransactionalOperator.transactional extensions instead.");
				}
				ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(method.getReturnType());
				if (adapter == null) {
					throw new IllegalStateException("Cannot apply reactive transaction to non-reactive return type: " +
							method.getReturnType());
				}
				return new ReactiveTransactionSupport(adapter);
			});
			return txSupport.invokeWithinTransaction(
					method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);
		}

		PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
		//构造方法的唯一标示 (类.方法，如 UserServiceImpl.save)
		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

		//声明式事务处理
		if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
			// Standard transaction demarcation with getTransaction and commit/rollback calls.
			// 创建 TransactionInfo
			TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);

			Object retVal;
			try {
				// This is an around advice: Invoke the next interceptor in the chain.
				// This will normally result in a target object being invoked.
				// 执行增强方法
				retVal = invocation.proceedWithInvocation();
			}
			catch (Throwable ex) {
				// target invocation exception
				//异常回滚
				completeTransactionAfterThrowing(txInfo, ex);
				throw ex;
			}
			finally {
				//清除信息
				cleanupTransactionInfo(txInfo);
			}

			if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {
				// Set rollback-only in case of Vavr failure matching our rollback rules...
				TransactionStatus status = txInfo.getTransactionStatus();
				if (status != null && txAttr != null) {
					retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
				}
			}

			//提交事务
			commitTransactionAfterReturning(txInfo);
			return retVal;
		}

		else {
			final ThrowableHolder throwableHolder = new ThrowableHolder();

			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
			// 编程式事务处理
			try {
				Object result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -> {
					TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);
					try {
						Object retVal = invocation.proceedWithInvocation();
						if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {
							// Set rollback-only in case of Vavr failure matching our rollback rules...
							retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
						}
						return retVal;
					}
					catch (Throwable ex) {
						if (txAttr.rollbackOn(ex)) {
							// A RuntimeException: will lead to a rollback.
							if (ex instanceof RuntimeException) {
								throw (RuntimeException) ex;
							}
							else {
								throw new ThrowableHolderException(ex);
							}
						}
						else {
							// A normal return value: will lead to a commit.
							throwableHolder.throwable = ex;
							return null;
						}
					}
					finally {
						cleanupTransactionInfo(txInfo);
					}
				});

				// Check result state: It might indicate a Throwable to rethrow.
				if (throwableHolder.throwable != null) {
					throw throwableHolder.throwable;
				}
				return result;
			}
			catch (ThrowableHolderException ex) {
				throw ex.getCause();
			}
			catch (TransactionSystemException ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
					ex2.initApplicationException(throwableHolder.throwable);
				}
				throw ex2;
			}
			catch (Throwable ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
				}
				throw ex2;
			}
		}
	}
 ```
&emsp;&emsp;在上面的函数中，我们尝试整理下事务处理的脉络，在 Spring 中支持两种事务处理的方式，分别是声明式事务处理与编程式事务处理，两者相对于开发人员来将差别很大，但是对于 Spring 中的实现来将，大同小异。在invoke中我们可以看到这两种方式的实现。考虑到事务的应用声明式事务处理使用起来方便，也相对流行些，我们就以此种方法进行分析。对于声明式事务处理主要有以下几个步骤。
1. 获取事务的属性。
&emsp;&emsp;对于事务来说，最基础或者说最首要的工作便是获取事务属性了，这是支撑整个事务功能的基石，如果没有事务属性，其他功能也无从谈起，在分析事务准备阶段时我们已经分析了事务属性提取的功能，大家应该有所了解。
1. 加载配置中的TransactionManager。
1. 不同的事务处理方式使用不同的逻辑。
&emsp;&emsp;对于声明式事务的处理与编程式事务的处理，低一点区别在于事务属性上，因为编程式的事务处理是不需要有事务属性的，第二点区别就是在 TransactionManager 上，CallPreferringPlatformTransactionManager 实现 PlatformTransactionManager 接口，暴露出一个方法用于执行事务处理中的回调。所以，这两种方式都可以用作事务处理方式的判断。
1. 在目标方法执行前获取事务并手机事务信息。
&emsp;&emsp;事务信息与事务属性并不相同，也就是 TransactionInfo 与 TransactionAttribute 并不相同， TransactionInfo 中包含了 TransactionAttribute 信息，但是，除了 TransactionAttribute 外还有其他事务信息，例如 PlatformTransactionManager 以及 TransactionStatus 相关信息。
1. 执行目标方法。
1. 一旦出现异常，尝试异常处理。
&emsp;&emsp;并不是所有异常，Spring 都会将其回滚，默认只对 RuntimeException 回滚。
1. 提交事务前的事务信息清除。
1. 提交事务。

### 10.3.1 创建事务
 ```java
 	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {

		// If no name specified, apply method identification as transaction name.
		// 如果没有名称指定则使用方法唯一标识，并使用 DelegatingTransactionAttribute 封装 txAttr
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				//获取 TransactionStatus
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		//根据指定的属性与status准备一个 TransactionInfo
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}
 ```
&emsp;&emsp;对于 createTransactionIfNecessary 函数主要做了这样几件事情。
1. 使用 DelegatingTransactionAttribute 封装传入 的 TransactionAttribute 实例。
&emsp;&emsp;对于传入 TransactionAtribute 类型的参数 txAttr，当前的实际类型是 RuleBasedTransactionAttribute， 是由获取事务属性时生成，主要用于数据承载，而这里之所以使用 DelegatingTransactionAttribute 进行封装，当然是提供了更多的功能。
1. 获取事务。
&emsp;&emsp;事务处理当然以事务为核心，那么获取事务就是最重要的事情。
1. 构建事务信息
&emsp;&emsp;根据之前几个步骤获取的信息构建 TransactionInfo 并返回。

#### 1. 获取事务
&emsp;&emsp;Spring 中使用 getTransaction 来处理事务的准备工作，包括事务获取以及信息构建。
> AbstractPlatformTransactionManager
 ```java
	@Override
	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException {

		// Use defaults if no transaction definition given.
		// 如果没有 事务定义(属性)，则使用默认的
		TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());

		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();

		//判断当前线程是否存在事务，判断依据为当前线程记录的连接不为空且连接中(connectionHolder)中的transactionActive属性不为空
		if (isExistingTransaction(transaction)) {
			// Existing transaction found -> check propagation behavior to find out how to behave.
			//当前线程已存在事务，检查事务传播行为，以判断如何处理
			return handleExistingTransaction(def, transaction, debugEnabled);
		}

		// Check definition settings for new transaction.
		// 判断事务超时设置验证
		if (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException("Invalid transaction timeout", def.getTimeout());
		}

		// No existing transaction found -> check propagation behavior to find out how to proceed.
		// 不存在事务，检查事务传播行为，以判断如何处理
		// propagation 被声明为 PROPAGATION_MANDATORY(必须存在事务) 抛出异常
		if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					"No existing transaction found for transaction marked with propagation 'mandatory'");
		}
		// propagation 被声明为 PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED 则都需要新建事务
		else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			//新建事务
			//空挂起
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug("Creating new transaction with name [" + def.getName() + "]: " + def);
			}
			try {
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						def, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				/*
				 * 构造 transaction，包括设置 ConnectionHolder，隔离级别、timeout
				 * 如果是新连接，绑定到当前线程
				 */
				doBegin(transaction, def);
				//新同步事务的设置，针对当前线程的设置
				prepareSynchronization(status, def);
				return status;
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// Create "empty" transaction: no actual transaction, but potentially synchronization.
			if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
				logger.warn("Custom isolation level specified but no actual transaction initiated; " +
						"isolation level will effectively be ignored: " + def);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
		}
	}
 ```
&emsp;&emsp;现在我们先来看看事务的准备工作都包括哪些。
1. 获取事务。
&emsp;&emsp;创建对应的事务实例，这里使用的是 DataSourceTransactionManager 中的 doGetTransaction 方法，创建基于JDBC的事务实例。如果当线程中存在关于 dataSource 的连接，那么直接使用。这里有一个对保存点的设置，是否开启允许保存点取决于是否允许嵌入式事务。
 ```java
 	@Override
	protected Object doGetTransaction() {
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		//如果当前线程已经记录数据库连接，则使用原有连接
		//这里如果是没有开启事务的情况下，获取到的对应的conHolder为空，在doBegin的时候才会新建对应的connection和设置事务标志
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		//false 标示非新建连接
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
 ```
2. 如果当线程存在事务，则转向嵌套事务的处理。
3. 事务超时设置验证。
4. 事务 propagationBehavior 属性的设置验证。
5. 构建 DefaultTransactionStatus
6. 完善 transaction，包括 设置 ConnectionHolder、隔离级别、timeout，如果是新连接，则绑定到当前线程。
&emsp;&emsp;对于一些隔离级别，timeout等功能的设置并不是由Spring来完成的，而是委托给底层的数据库连接去做的，而对于数据库连接的设置就是在 doBegin 函数中处理的。
 ```java
	/**
	 * This implementation sets the isolation level but ignores the timeout.
	 * 构造 transaction，包括设置 ConnectionHolder 、隔离级别、 timeout
	 * 如果是新连接，绑定到当前线程
	 */
	@Override
	protected void doBegin(Object transaction, TransactionDefinition definition) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
		Connection con = null;

		try {
			//如果 DataSourceTransactionObject 没有ConnectionHolder 或者没有开启事务
			if (!txObject.hasConnectionHolder() ||
					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
				//重新获取 Connection
				Connection newCon = obtainDataSource().getConnection();
				if (logger.isDebugEnabled()) {
					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction");
				}
				//重新封装到 DataSourceTransactionObject 中
				txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
			}

			//设置 ConnectionHolder 开启事务
			txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
			//获取数据库连接
			con = txObject.getConnectionHolder().getConnection();

			//设置隔离级别
			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
			txObject.setPreviousIsolationLevel(previousIsolationLevel);
			txObject.setReadOnly(definition.isReadOnly());

			// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,
			// so we don't want to do it unnecessarily (for example if we've explicitly
			// configured the connection pool to set it already).
			// 如果有需要切换为手动提交
			if (con.getAutoCommit()) {
				txObject.setMustRestoreAutoCommit(true);
				if (logger.isDebugEnabled()) {
					logger.debug("Switching JDBC Connection [" + con + "] to manual commit");
				}
				con.setAutoCommit(false);
			}

			//如果是
			prepareTransactionalConnection(con, definition);
			//设置判断当前线程是否存在事务的依据
			txObject.getConnectionHolder().setTransactionActive(true);

			int timeout = determineTimeout(definition);
			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
			}

			// Bind the connection holder to the thread.
			// 如果是新建的ConnectionHolder 则将当前获取的连接绑定到当前线程
			if (txObject.isNewConnectionHolder()) {
				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
			}
		}

		catch (Throwable ex) {
			if (txObject.isNewConnectionHolder()) {
				DataSourceUtils.releaseConnection(con, obtainDataSource());
				txObject.setConnectionHolder(null, false);
			}
			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex);
		}
	}
 ```
* doBegin
&emsp;&emsp;可以说事务是从这个函数开始的，因为在这个函数中已经开始尝试了对数据库连接的获取，当然，在获取数据库连接的同时，一些必要的设置也是需要同步设置的。
	1. 尝试获取连接。
&emsp;&emsp;当然并不是没吃都会获取新的连接，如果当前线程中的 connectionHolder 已经存在，则没有必要再次获取，或者，对于事务同步标示设置为true的需要重新获取连接。
	1. 设置隔离级别以及只读标识。
&emsp;&emsp;事务中的只读配置是Spring中做了一些处理，Spring 中缺失是针对只读操作做了一些处理，但是核心的实现是设置 connection 上的 readOnly 属性。同样对于隔离级别的控制也是交由 connection 去控制的。
	1. 更改默认的提交设置
&emsp;&emsp;如果事务属性是自动提交，那么需要改变这种设置，而将提交操作委托给 Spring 来处理。
	1. 设置标志位，标识当前连接已经被事务激活。
	1. 设置过期时间。
	1. 将 connectionHolder 绑定到当前线程。

&emsp;&emsp;设置隔离级别的 prepareConnectionFortransaction 函数用于负责对底层数据库连接的设置，当然，只是包含只读标识和隔离级别的设置。由于强大的日志及异常处理，显得函数代码量比较大，但是单从业务角度去看，关键代码其实不多。
 ```java
	@Nullable
	public static Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)
			throws SQLException {

		Assert.notNull(con, "No Connection specified");

		// Set read-only flag.
		// 设置数据库连接的只读标志
		if (definition != null && definition.isReadOnly()) {
			try {
				if (logger.isDebugEnabled()) {
					logger.debug("Setting JDBC Connection [" + con + "] read-only");
				}
				con.setReadOnly(true);
			}
			catch (SQLException | RuntimeException ex) {
				Throwable exToCheck = ex;
				while (exToCheck != null) {
					if (exToCheck.getClass().getSimpleName().contains("Timeout")) {
						// Assume it's a connection timeout that would otherwise get lost: e.g. from JDBC 4.0
						throw ex;
					}
					exToCheck = exToCheck.getCause();
				}
				// "read-only not supported" SQLException -> ignore, it's just a hint anyway
				logger.debug("Could not set JDBC Connection read-only", ex);
			}
		}

		// Apply specific isolation level, if any.
		// 设置当前事务的隔离级别
		Integer previousIsolationLevel = null;
		if (definition != null && definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
			if (logger.isDebugEnabled()) {
				logger.debug("Changing isolation level of JDBC Connection [" + con + "] to " +
						definition.getIsolationLevel());
			}
			int currentIsolation = con.getTransactionIsolation();
			if (currentIsolation != definition.getIsolationLevel()) {
				previousIsolationLevel = currentIsolation;
				con.setTransactionIsolation(definition.getIsolationLevel());
			}
		}

		return previousIsolationLevel;
	}
 ```
7. 记录事务信息到当前线程中
 ```java
 	protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {
		if (status.isNewSynchronization()) {
			TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());
			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(
					definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?
							definition.getIsolationLevel() : null);
			TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
			TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());
			TransactionSynchronizationManager.initSynchronization();
		}
	}
 ```
#### 2. 处理已存在的事务
&emsp;&emsp;之前讲述了普通事务建立的过程，但是 Spring 中支持多种事务的传播规则，比如 PROPAGATION_NESTED、PROPAGATION_REQUIRES_NEW 等，这些都是在已经存在的事务的基础上进行进一步的处理，那么，对于已经存在的事务，准备操作如何进行的呢？
 ```java
	/**
	 * Create a TransactionStatus for an existing transaction.
	 */
	private TransactionStatus handleExistingTransaction(
			TransactionDefinition definition, Object transaction, boolean debugEnabled)
			throws TransactionException {

		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
			throw new IllegalTransactionStateException(
					"Existing transaction found for transaction marked with propagation 'never'");
		}

		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction");
			}
			Object suspendedResources = suspend(transaction);
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(
					definition, null, false, newSynchronization, debugEnabled, suspendedResources);
		}

		// 新事务的建立
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction, creating new transaction with name [" +
						definition.getName() + "]");
			}
			SuspendedResourcesHolder suspendedResources = suspend(transaction);
			try {
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				doBegin(transaction, definition);
				prepareSynchronization(status, definition);
				return status;
			}
			catch (RuntimeException | Error beginEx) {
				resumeAfterBeginException(transaction, suspendedResources, beginEx);
				throw beginEx;
			}
		}

		//嵌入式事务的处理
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			if (!isNestedTransactionAllowed()) {
				throw new NestedTransactionNotSupportedException(
						"Transaction manager does not allow nested transactions by default - " +
						"specify 'nestedTransactionAllowed' property with value 'true'");
			}
			if (debugEnabled) {
				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");
			}
			if (useSavepointForNestedTransaction()) {
				// Create savepoint within existing Spring-managed transaction,
				// through the SavepointManager API implemented by TransactionStatus.
				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.
				// 如果没有可以使用保存点的方式控制事务回滚，那么在嵌入式事务的建立之处就建立保存点
				DefaultTransactionStatus status =
						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
				status.createAndHoldSavepoint();
				return status;
			}
			else {
				// Nested transaction through nested begin and commit/rollback calls.
				// Usually only for JTA: Spring synchronization might get activated here
				// in case of a pre-existing JTA transaction.
				//有些情况不能使用保存点，比如 JTA，那么建立新事务
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, null);
				doBegin(transaction, definition);
				prepareSynchronization(status, definition);
				return status;
			}
		}

		// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.
		if (debugEnabled) {
			logger.debug("Participating in existing transaction");
		}
		if (isValidateExistingTransaction()) {
			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {
					Constants isoConstants = DefaultTransactionDefinition.constants;
					throw new IllegalTransactionStateException("Participating transaction with definition [" +
							definition + "] specifies isolation level which is incompatible with existing transaction: " +
							(currentIsolationLevel != null ?
									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
									"(unknown)"));
				}
			}
			if (!definition.isReadOnly()) {
				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
					throw new IllegalTransactionStateException("Participating transaction with definition [" +
							definition + "] is not marked as read-only but existing transaction is");
				}
			}
		}
		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
	}
 ```
&emsp;&emsp;对于已经存在事务的处理过程中，我们看到了很多熟悉的操作，但是，也有些不同的地方，函数中对已经存在的事务处理考虑两种情况。
* PROPAGATION_REQUIRES_NEW 表示当前方法必须在它自己的事务里运行，一个新的事务将被启动，而如果一个事务正在运行的话，那么则在这个方法运行期间被挂起。而Spring中对于此种传播方式的处理与新鲜事务建立最大的不同点在于使用 suspend 方法将原事务挂起。将信息挂起的目的当然是为了在当前事务执行完毕后在将原事务还原。
* PROPAGATION_NESTED 表示如果当前正有一个事务在运行中，则该方法应该运行在一个嵌套的事务中，被嵌套的事务可以独立于封装事务进行提交或者回滚，如果封装事务不存在，行为就像 PROPAGATION_REQUIRES_NEW。对于嵌入式事务的处理，Spring主要考虑两种方式的处理。
	* Spring 中允许嵌入事务的时候，则首选设置保存点的方式作为异常处理的回滚。
	* 对于其他方式，比如 JTA 方式无法使用保存点的方式，那么处理方式于 PROPAGATION_REQUIRES_NEW 相同，而一旦出现异常，则由Spring的事务异常处理机制去完成后续处理。
&emsp;&emsp;对于挂起操作的主要目的是记录原有事务的状态，以便于后续操作对事务的恢复：
 ```java
	/**
	 * Suspend the given transaction. Suspends transaction synchronization first,
	 * then delegates to the {@code doSuspend} template method.
	 * @param transaction the current transaction object
	 * (or {@code null} to just suspend active synchronizations, if any)
	 * @return an object that holds suspended resources
	 * (or {@code null} if neither transaction nor synchronization active)
	 * @see #doSuspend
	 * @see #resume
	 */
	@Nullable
	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {
		if (TransactionSynchronizationManager.isSynchronizationActive()) {
			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization();
			try {
				Object suspendedResources = null;
				if (transaction != null) {
					suspendedResources = doSuspend(transaction);
				}
				String name = TransactionSynchronizationManager.getCurrentTransactionName();
				TransactionSynchronizationManager.setCurrentTransactionName(null);
				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
				TransactionSynchronizationManager.setActualTransactionActive(false);
				return new SuspendedResourcesHolder(
						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
			}
			catch (RuntimeException | Error ex) {
				// doSuspend failed - original transaction is still active...
				doResumeSynchronization(suspendedSynchronizations);
				throw ex;
			}
		}
		else if (transaction != null) {
			// Transaction active but no synchronization active.
			Object suspendedResources = doSuspend(transaction);
			return new SuspendedResourcesHolder(suspendedResources);
		}
		else {
			// Neither transaction nor synchronization active.
			return null;
		}
	}
 ```

 #### 3. 准备事务信息
 &emsp;&emsp;当已经建立事务连接并完成了事务信息的提取后，我们需要将所有的事务信息统一记录在  TransactionInfo 类型的实例中，这个实例包含了目标方法开始前的所有状态信息，一旦事务执行失败，Spring 会通过 TransactionInfo 类型的实例中的信息来进行回滚等后续工作。
  ```java
  	protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, String joinpointIdentification,
			@Nullable TransactionStatus status) {

		TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
		if (txAttr != null) {
			// We need a transaction for this method...
			if (logger.isTraceEnabled()) {
				logger.trace("Getting transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			// The transaction manager will flag an error if an incompatible tx already exists.
			// 记录事务状态
			txInfo.newTransactionStatus(status);
		}
		else {
			// The TransactionInfo.hasTransaction() method will return false. We created it only
			// to preserve the integrity of the ThreadLocal stack maintained in this class.
			if (logger.isTraceEnabled()) {
				logger.trace("No need to create transaction for [" + joinpointIdentification +
						"]: This method is not transactional.");
			}
		}

		// We always bind the TransactionInfo to the thread, even if we didn't create
		// a new transaction here. This guarantees that the TransactionInfo stack
		// will be managed correctly even if no transaction was created by this aspect.
		txInfo.bindToThread();
		return txInfo;
	}
  ```

### 10.3.2 回滚处理
&emsp;&emsp;之前已经完成了目标方法运行前的事务准备工作，而这些准备工作最大的目的无非是对程序没有按照我们期待的那样进行，也就是出现特定错误，那么，当出现错误的时候，Spring 是怎么对数据进行恢复的呢？
> TransactionAspectjSupport
 ```java
	/**
	 * Handle a throwable, completing the transaction.
	 * We may commit or roll back, depending on the configuration.
	 * @param txInfo information about the current transaction
	 * @param ex throwable encountered
	 */
	protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
		//当抛出异常时首先判断是否存在事务，这是基础依据
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +
						"] after exception: " + ex);
			}
			//这里判断是否回滚默认的依据时抛出的异常是否有 RuntimeException 或者时 Error 类型
			if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {
				try {
					//根据 TransactionStatus 信息进行回滚处理
					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					throw ex2;
				}
			}
			else {
				// We don't roll back on this exception.
				// Will still roll back if TransactionStatus.isRollbackOnly() is true.
				// 如果不满足回滚条件即使抛出异常也可能会提交
				try {
					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					throw ex2;
				}
			}
		}
	}
 ```
&emsp;&emsp;在对目标方法的执行过程中，一旦出现 Throwable 就会被引导至此方法处理，但是并不代表所有的 Throwable 都会被回滚处理，比如我们常用的Exception，默认是不会被处理的。默认情况下，即使出现异常，数据也会被提交，而这个关键的地方就在于txInfo.transactionAttribute.rollbackOn(ex)这个函数。
1. 回滚条件
 ```java
	// DefaultTransactionAttribute
	@Override
	public boolean rollbackOn(Throwable ex) {
		return (ex instanceof RuntimeException || ex instanceof Error);
	}
 ```
&emsp;&emsp;当然我们可以通过扩展来改变，不过，我们最常用的还是使用事务提供的属性配置，利用注解方式的使用，例如：@Transaction(propagation=Propagation.REQUIRED,rollback=Exception.class)
2. 回滚处理
&emsp;&emsp;当然，一旦符合回滚条件，那么Spring就会将程序引导至回滚处理函数中。
 ```java
 	@Override
	public final void rollback(TransactionStatus status) throws TransactionException {
		if (status.isCompleted()) {
			throw new IllegalTransactionStateException(
					"Transaction is already completed - do not call commit or rollback more than once per transaction");
		}

		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
		processRollback(defStatus, false);
	}

	/**
	 * Process an actual rollback.
	 * The completed flag has already been checked.
	 * @param status object representing the transaction
	 * @throws TransactionException in case of rollback failure
	 */
	private void processRollback(DefaultTransactionStatus status, boolean unexpected) {
		try {
			boolean unexpectedRollback = unexpected;

			try {
				//激活所有 TransactionSynchronization 中对应的方法
				triggerBeforeCompletion(status);

				if (status.hasSavepoint()) {
					if (status.isDebug()) {
						logger.debug("Rolling back transaction to savepoint");
					}
					//如果有保存点，也就是当前事务为单独的线程，则会退到保存点
					status.rollbackToHeldSavepoint();
				}
				else if (status.isNewTransaction()) {
					if (status.isDebug()) {
						logger.debug("Initiating transaction rollback");
					}
					//如果当前事务为独立的新事务，则直接回退
					doRollback(status);
				}
				else {
					// Participating in larger transaction
					if (status.hasTransaction()) {
						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
							if (status.isDebug()) {
								logger.debug("Participating transaction failed - marking existing transaction as rollback-only");
							}
							doSetRollbackOnly(status);
						}
						else {
							if (status.isDebug()) {
								logger.debug("Participating transaction failed - letting transaction originator decide on rollback");
							}
						}
					}
					else {
						logger.debug("Should roll back transaction but cannot - no transaction available");
					}
					// Unexpected rollback only matters here if we're asked to fail early
					if (!isFailEarlyOnGlobalRollbackOnly()) {
						unexpectedRollback = false;
					}
				}
			}
			catch (RuntimeException | Error ex) {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
				throw ex;
			}

			//激活所有TransactionSynchronization中对应的方法
			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);

			// Raise UnexpectedRollbackException if we had a global rollback-only marker
			if (unexpectedRollback) {
				throw new UnexpectedRollbackException(
						"Transaction rolled back because it has been marked as rollback-only");
			}
		}
		finally {
			//清空记录的资源并将挂起的资源恢复
			cleanupAfterCompletion(status);
		}
	}
 ```
&emsp;&emsp;同样，对于Spring中的复杂的逻辑处理，在入口函数一般都会给出个整体的脉络，而把实现细节委托给其他函数去执行。我们尝试总结下Spring中对回滚处理的大致脉络入下。
1. 首先是自定义触发器的调用，包括在回滚前，回顾完成后的调用，当然完成回滚包括正常回滚与回滚过程中出现异常，自定义的触发器会根据这些信息做进一步的处理，而对于触发器的注册，常见是在回调过程中通过 TransactionSynchronizationManager类中的静态方法直接注册：
 ```java
 public static void registerSynchronization(TransactionSynchronization synchronization)
 ```
2. 除了出发监听函数外，就是真正的回滚逻辑处理了。
	* 当之前已经保存的事务信息中有保存点信息的时候，使用保存点信息进行回滚。常用于嵌入式事务，对于嵌入式事务的处理，内嵌的事务异常并不会引起外部事务的回滚。

&emsp;&emsp;根据保存点回滚的实现方式其实是根据底层的数据库连接进行的。
 ```java
 	/**
	 * Roll back to the savepoint that is held for the transaction
	 * and release the savepoint right afterwards.
	 */
	public void rollbackToHeldSavepoint() throws TransactionException {
		Object savepoint = getSavepoint();
		if (savepoint == null) {
			throw new TransactionUsageException(
					"Cannot roll back to savepoint - no savepoint associated with current transaction");
		}
		getSavepointManager().rollbackToSavepoint(savepoint);
		getSavepointManager().releaseSavepoint(savepoint);
		setSavepoint(null);
	}
 ```
&emsp;&emsp;这里使用的是JDBC的方式进行数据库连接，那么 getSavepointManager() 函数返回的是 JdbcTransactionObjectSupport，也就是上面函数会调用 JdbcTransactionObjectSupport 中的 rollbackToSavepoint 方法。
 ```java
 	/**
	 * This implementation rolls back to the given JDBC 3.0 Savepoint.
	 * @see java.sql.Connection#rollback(java.sql.Savepoint)
	 */
	@Override
	public void rollbackToSavepoint(Object savepoint) throws TransactionException {
		ConnectionHolder conHolder = getConnectionHolderForSavepoint();
		try {
			conHolder.getConnection().rollback((Savepoint) savepoint);
			conHolder.resetRollbackOnly();
		}
		catch (Throwable ex) {
			throw new TransactionSystemException("Could not roll back to JDBC savepoint", ex);
		}
	}
 ```
 * 当之前已经保存的事务信息中的事务为新事务，那么直接回滚。常用于单独事务的处理。对于没有保存点的回滚，Spring 同样是使用底层数据库连接提供的API来操作的。由于我们使用的是DataSourceTransactionManager ，那么 doRollback 函数会直接使用此类中的实现：
 ```java
 	@Override
	protected void doRollback(DefaultTransactionStatus status) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
		Connection con = txObject.getConnectionHolder().getConnection();
		if (status.isDebug()) {
			logger.debug("Rolling back JDBC transaction on Connection [" + con + "]");
		}
		try {
			con.rollback();
		}
		catch (SQLException ex) {
			throw new TransactionSystemException("Could not roll back JDBC transaction", ex);
		}
	}
 ```
 * 当事务信息中表明是存在事务的，又不属于以上两种情况，多数用于JTA，只做回滚标识，等到提交的时候统一不提交。

3. 回滚后的信息清除
&emsp;&emsp;对于回滚逻辑执行结束后，无论回滚是否成功，都必须要做的事情就是事务结束后的收尾工作。
 ```java
 	/**
	 * Clean up after completion, clearing synchronization if necessary,
	 * and invoking doCleanupAfterCompletion.
	 * @param status object representing the transaction
	 * @see #doCleanupAfterCompletion
	 */
	private void cleanupAfterCompletion(DefaultTransactionStatus status) {
		//设置完成状态
		status.setCompleted();
		if (status.isNewSynchronization()) {
			TransactionSynchronizationManager.clear();
		}
		if (status.isNewTransaction()) {
			doCleanupAfterCompletion(status.getTransaction());
		}
		if (status.getSuspendedResources() != null) {
			if (status.isDebug()) {
				logger.debug("Resuming suspended transaction after completion of inner transaction");
			}
			Object transaction = (status.hasTransaction() ? status.getTransaction() : null);
			//结束之前事务的挂起状态
			resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());
		}
	}
 ```
&emsp;&emsp;从函数中得知，事务处理的收尾处理工作包括如下内容。
* 设置状态是丢事务信息作完成标示以避免重复调用。
* 如果当前事务是新的同步状态，需要将绑定到当前线程的事务信息清除。
* 如果是新事务需要作些清除资源的工作。
 ```java
	@Override
	protected void doCleanupAfterCompletion(Object transaction) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;

		// Remove the connection holder from the thread, if exposed.
		// 将数据库连接从当前线程中解除绑定
		if (txObject.isNewConnectionHolder()) {
			TransactionSynchronizationManager.unbindResource(obtainDataSource());
		}

		// Reset connection.
		// 释放连接
		Connection con = txObject.getConnectionHolder().getConnection();
		try {
			if (txObject.isMustRestoreAutoCommit()) {
				//恢复数据库连接自动提交属性
				con.setAutoCommit(true);
			}
			//重置数据库连接
			DataSourceUtils.resetConnectionAfterTransaction(
					con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());
		}
		catch (Throwable ex) {
			logger.debug("Could not reset JDBC Connection after transaction", ex);
		}

		if (txObject.isNewConnectionHolder()) {
			if (logger.isDebugEnabled()) {
				logger.debug("Releasing JDBC Connection [" + con + "] after transaction");
			}
			// 如果当前事务是独立的新创建的事务则在事务完成时释放数据库连接
			DataSourceUtils.releaseConnection(con, this.dataSource);
		}

		txObject.getConnectionHolder().clear();
	}
 ```
* 如果在事务执行前有事务挂起，那么当前事务执行结束后需要将挂起事务恢复。
 ```java
	protected final void resume(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)
			throws TransactionException {

		if (resourcesHolder != null) {
			Object suspendedResources = resourcesHolder.suspendedResources;
			if (suspendedResources != null) {
				doResume(transaction, suspendedResources);
			}
			List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;
			if (suspendedSynchronizations != null) {
				TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);
				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);
				TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);
				TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);
				doResumeSynchronization(suspendedSynchronizations);
			}
		}
	}
 ```

 ### 10.3.3 事务提交
 &emsp;&emsp;之前我们分析了 Spring 的事务异常处理机制，那么事务的执行并没有出现任何的异常，也就意味着事务可以走中粮广场事务提交的流程了。
  ```java
	/**
	 * Execute after successful completion of call, but not after an exception was handled.
	 * Do nothing if we didn't create a transaction.
	 * @param txInfo information about the current transaction
	 */
	protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
		}
	}
  ```
&emsp;&emsp;真正数据提交之前，还需要作一个判断。不知道大家还有没有印象，我们分析事务异常处理规则的时候，当某个事务既没有保存点又不是新事务，Spring对它的处理方式只是设置一个回滚标志。这个回滚标志在这里就会派上用场了，主要的应用场景如下。
&emsp;&emsp;某个事务是另一个事务的嵌入事务，但是，这些事务又不再Spring的管理范围内，或者无法设置保存点，那么Spring会通过设置回滚标识，而等到外部事务提交时，一旦判断出当前事务流被设置了回滚标识，则由外部事务来统一进行整体事务的回滚。
&emsp;&emsp;所以，当事务没有被异常补货的时候也并不意味着一定会执行提交的过程。
 ```java
	@Override
	public final void commit(TransactionStatus status) throws TransactionException {
		if (status.isCompleted()) {
			throw new IllegalTransactionStateException(
					"Transaction is already completed - do not call commit or rollback more than once per transaction");
		}

		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
		//如果在事务链中已经被标记回滚，那么不会尝试提交事务，直接回滚
		if (defStatus.isLocalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Transactional code has requested rollback");
			}
			processRollback(defStatus, false);
			return;
		}

		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit");
			}
			processRollback(defStatus, true);
			return;
		}
		//处理事务提交
		processCommit(defStatus);
	}
 ```
&emsp;&emsp;而当事务一切都正常的时候，便可以真正地进入提交流程了。
 ```java
	/**
	 * Process an actual commit.
	 * Rollback-only flags have already been checked and applied.
	 * @param status object representing the transaction
	 * @throws TransactionException in case of commit failure
	 */
	private void processCommit(DefaultTransactionStatus status) throws TransactionException {
		try {
			boolean beforeCompletionInvoked = false;

			try {
				boolean unexpectedRollback = false;
				// 预留
				prepareForCommit(status);
				// 添加的 TransactionSynchronization 中的对应方法的调用
				triggerBeforeCommit(status);
				triggerBeforeCompletion(status);
				beforeCompletionInvoked = true;

				if (status.hasSavepoint()) {
					if (status.isDebug()) {
						logger.debug("Releasing transaction savepoint");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					//如果存在保存点则清除保存点信息
					status.releaseHeldSavepoint();
				}
				else if (status.isNewTransaction()) {
					if (status.isDebug()) {
						logger.debug("Initiating transaction commit");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					// 如果是独立的事务则直接提交
					doCommit(status);
				}
				else if (isFailEarlyOnGlobalRollbackOnly()) {
					unexpectedRollback = status.isGlobalRollbackOnly();
				}

				// Throw UnexpectedRollbackException if we have a global rollback-only
				// marker but still didn't get a corresponding exception from commit.
				if (unexpectedRollback) {
					throw new UnexpectedRollbackException(
							"Transaction silently rolled back because it has been marked as rollback-only");
				}
			}
			catch (UnexpectedRollbackException ex) {
				// can only be caused by doCommit
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
				throw ex;
			}
			catch (TransactionException ex) {
				// can only be caused by doCommit
				if (isRollbackOnCommitFailure()) {
					doRollbackOnCommitException(status, ex);
				}
				else {
					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
				}
				throw ex;
			}
			catch (RuntimeException | Error ex) {
				if (!beforeCompletionInvoked) {
					//添加的TransactionSynchronization中的对应方法的调用
					triggerBeforeCompletion(status);
				}
				//提交过程中出现异常则回滚
				doRollbackOnCommitException(status, ex);
				throw ex;
			}

			// Trigger afterCommit callbacks, with an exception thrown there
			// propagated to callers but the transaction still considered as committed.
			try {
				// 添加的 TransactionSynchronization 中的对应方法的调用
				triggerAfterCommit(status);
			}
			finally {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
			}

		}
		finally {
			cleanupAfterCompletion(status);
		}
	}
 ```
&emsp;&emsp;在提交过程中也并不是直接提交的，而是考虑了诸多的方面，符合提交的条件如下。
* 当事务状态中有保存点信息的话便不会提交事务。
* 当事务非新事务的时候也不会去执行提交事务操作。
&emsp;&emsp;此提交主要考虑内嵌事务的情况，对于内嵌事务，Spring中正常的处理方式是将内嵌事务开始之前设置保存点，一旦内嵌事务出现异常便根据保存点信息回滚，但是如果没有出现异常，内嵌事务并不会单独提交，而是根据事务流由最外层事务负责提交，所以如果当前存在保存点信息便不是最外层事务，不做保存操作，对于是否是新事务的判断也是基于此考虑。
&emsp;&emsp;如果程序流通过了事务的层层把关，最后顺利地进入了提交流程，那么同样，Spring会将事务提交的操作引导至数据库连接的API，进行事务提交。
 ```java
	@Override
	protected void doCommit(DefaultTransactionStatus status) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
		Connection con = txObject.getConnectionHolder().getConnection();
		if (status.isDebug()) {
			logger.debug("Committing JDBC transaction on Connection [" + con + "]");
		}
		try {
			con.commit();
		}
		catch (SQLException ex) {
			throw new TransactionSystemException("Could not commit JDBC transaction", ex);
		}
	}
 ```