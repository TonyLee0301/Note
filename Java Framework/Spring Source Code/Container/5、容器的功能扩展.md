# 5 容器的功能扩展

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [5 容器的功能扩展](#5-容器的功能扩展)
  - [5.1 设置配置路径](#51-设置配置路径)
  - [5.2 扩展功能](#52-扩展功能)
  - [5.3 环境准备](#53-环境准备)
  - [5.4 加载 BeanFactory](#54-加载-beanfactory)
    - [5.4.1 定制 BeanFactory](#541-定制-beanfactory)
    - [6.4.2 加载BeanDefinition](#642-加载beandefinition)
  - [5.5 功能扩展](#55-功能扩展)
    - [5.5.1 增加SpEL语言的支持](#551-增加spel语言的支持)
    - [5.5.2 增加属性注册编辑器](#552-增加属性注册编辑器)
      - [1. 使用自定义属性编辑器](#1-使用自定义属性编辑器)
      - [2. 注入 Spring 自带的属性编辑器 CustomDateEditor](#2-注入-spring-自带的属性编辑器-customdateeditor)
    - [5.5.3 添加 ApplicationContextAwareProcessor 处理器](#553-添加-applicationcontextawareprocessor-处理器)
    - [5.5.4 设置忽略依赖](#554-设置忽略依赖)
    - [5.5.5 注册依赖](#555-注册依赖)
  - [5.6 BeanFactory 的后处理](#56-beanfactory-的后处理)
    - [5.6.1 激活注册的 BeanFactoryPostProcessor](#561-激活注册的-beanfactorypostprocessor)
    - [5.6.2 使用自定义 BeanFactoryPostProcessor](#562-使用自定义-beanfactorypostprocessor)
    - [5.6.3 激活 BeanFactoryPostProcessor](#563-激活-beanfactorypostprocessor)
    - [5.6.2 注册 BeanPostProcessor](#562-注册-beanpostprocessor)

<!-- /code_chunk_output -->

&emsp;&emsp;经过前面的分析，相信大家对Spring中的容器功能有了简单的理解，之前我们一直以 BeanFactory 接口以及它的默认实现类 XmlBeanFactory 为例进行分析，但是 Spring 中还提供了另一个接口 ApplicationContext , 用于扩展 BeanFactory 中现有的功能。
&emsp;&emsp;ApplicationContext 和 BeanFacotry 两者都是用于加载 Bean 的，但是相比之下， ApplicationContext 提供了更多的扩展功能，简单一点说：ApplicationContext 包含 BeanFactory 的所有功能。通常建议比 BeanFactory 优先，除非在一些限制的场合，比如字节长度对内存有很大的影响时(Applet)。绝大多数“典型的”企业应用系统， ApplicationContext 就是你需要使用的。
&emsp;&emsp;那么究竟 ApplicationContext 比 BeanFactory 多出了哪些功能呢？还需要我们进一步的探索。首先我们来看看两个不同的类去加载配置文件的写法上的不同。
* 使用 BeanFactory 方式加载 XML
> BeanFactory bf = new XmlBeanFacotry(new ClassPathResource("beanFactoryTest.xml"));
* 使用 ApplicationContext 方式加载 XML
> ApplicationContext bf = new ClassPathXmlApplicationContext("beanFactoryTest.xml");
&emsp;&emsp;同样，我们还是以ClassPathXmlApplicationContext作为切入点，开始对整体功能进行分析。
 ```java
 public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
		this(new String[] {configLocation}, true, null);
 }
 public ClassPathXmlApplicationContext(
			String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
			throws BeansException {

		super(parent);
		setConfigLocations(configLocations);
		if (refresh) {
			refresh();
		}
 }
 ```
&emsp;&emsp;设置路径是必不可少的步骤，ClassPathXmlApplicationContext 中可以将配置文件路径以数组的方式传入， ClassPathXmlApplicationContext 可以对数组进行解析并进行加载。而对于解析及功能实现都在 refresh() 中实现。

## 5.1 设置配置路径
&emsp;&emsp;在 ClassPathXmlApplicationContext 中支持多个配置文件以数组方式同时传入：
 ```java
 public void setConfigLocations(@Nullable String... locations) {
		if (locations != null) {
			Assert.noNullElements(locations, "Config locations must not be null");
			this.configLocations = new String[locations.length];
			for (int i = 0; i < locations.length; i++) {
				//解析给定路径
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
 ```
 &emsp;&emsp;此解析函数主要用于解析给定的路径数组，当然，如果数组中包含特殊符号，那么如${var},那么在resolvePath中会搜寻匹配的系统变量并替换。

## 5.2 扩展功能
&emsp;&emsp;设置路径之后，便可以根据路径做配置文件的解析以及各种功能的实现了。可以说 refresh 函数中包含了几乎 ApplicationContext 中提供的全部功能，而且此函数中逻辑非常清晰明了，使我们很容易分析对应的层次及逻辑。
 ```java
    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.
            //准备刷新的上下文环境
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.
            // 初始化 BeanFactory ， 并进行 XML 文件读取
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            // 对 beanFactory 进行各种功能填充
            prepareBeanFactory(beanFactory);

            try {
                // Allows post-processing of the bean factory in context subclasses.
                // 子类覆盖方法做额外的处理
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                // 激活各种 BeanFactory 处理器
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                // 注册拦截Bean创建的 Bean 处理器，这里只是注册，真正的调用是在 getBean 的时候
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                // 为上下文初始化 Message 源， 即不同语言的消息体，国际化处理
                initMessageSource();

                // Initialize event multicaster for this context.
                // 初始化应用信息广播，并放入 "applicationEventMulticaster" bean 中
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                // 留给之类来初始化其他的bean
                onRefresh();

                // Check for listener beans and register them.
                // 在所有注册的 bean 中查找 Listener bean， 注册到消息广播器中
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                // 初始化剩下的单例(非惰性的)
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                // 完成刷新过程，通知声明周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEvent 通知别人
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Exception encountered during context initialization - " +
                            "cancelling refresh attempt: " + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring's core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }
  ```
&emsp;&emsp;下面概括一下 ClassPathXmlApplicationContext 初始化的步骤，并从中解释一下它为我们提供的功能。
1. 初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。 prepareRefresh()
&emsp;&emsp;在某种情况下项目的使用需要读取某些系统变量，而这个变量的设置很有可能会影响这系统的正确性，那么 ClassPathXmlApplicationContext 为我们提供的这个准备函数就显得非常必要，它可以在 Spring 启动的时候提前对必须的变量进行存在性验证。
2. 初始化BeanFactory，并进行XML文件读取。  obtainFreshBeanFactory()
&emsp;&emsp;之前有提到 ClassPathXmlApplicationContext 包含着 BeanFactory 所提供的一切特征，那么在这一步骤中将会复用 BeanFactory 中的配置文件读取解析及其他功能，这一步之后， ClassPathXmlApplicationContext 实际上就已经包含了 BeanFactory 说提供的功能，也就是可以进行bean的提取等基础操作了。
3. 对 BeanFacotry 进行各种功能填充。 prepareBeanFactory()
&emsp;&emsp; @Qualifier 与 @Autowired 应该是大家非常熟悉的注解，那么这两个解析正式在这一步骤中增加的支持。
4. 之类覆盖方法做额外的处理 postProcessBeanFactory()
&emsp;&emsp;Spring 之所以强大，为世人说推崇, 除了它功能上为大家提供了便利外，还有一方面是它完美架构，开放式的架构让使用它的程序员很容易根据业务需要扩展已经存在的功能。这种开放式的设计在 Spring 中随处可见。
5. 激活各种 BeanFactory 处理器。invokeBeanFactoryPostProcessors
6. 注册拦截 bean 创建的 bean 处理器，这里只是注册，真正的调用是在 getBean 时候。  registerBeanPostProcessors
7. 为上下文初始化 Message 源，即对不同语言的消息体进行国际化处理。 initMessageSource
8. 初始化应用消息广播器，并放入 "applicationEventMulticaster" bean 中。 initApplicationEventMulticaster
9. 留给之类来初始化其他 bean。 onRefresh
10. 在注册所有的 bean 中查找 listener bean， 注册到消息广播器中。 registerListeners
11. 初始化剩下的单示例(非惰性)。 finishBeanFactoryInitialization
12. 完成刷新过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEven 通知别人。 finishRefresh

## 5.3 环境准备
&emsp;&emsp; prepareRefresh 函数主要是做些准备工作，例如对系统属性及环境变量的初始化及验证。
 ```java
    protected void prepareRefresh() {
		// Switch to active.
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isDebugEnabled()) {
			if (logger.isTraceEnabled()) {
				logger.trace("Refreshing " + this);
			}
			else {
				logger.debug("Refreshing " + getDisplayName());
			}
		}

		// Initialize any placeholder property sources in the context environment.
		// 留给子类覆盖，初始化上下文环境的 占位符资源
		initPropertySources();

		// Validate that all properties marked as required are resolvable:
		// see ConfigurablePropertyResolver#setRequiredProperties
		// 验证需要的属性文件是否都已经放入环境中
		getEnvironment().validateRequiredProperties();

		// Store pre-refresh ApplicationListeners...
		if (this.earlyApplicationListeners == null) {
			this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
		}
		else {
			// Reset local application listeners to pre-refresh state.
			this.applicationListeners.clear();
			this.applicationListeners.addAll(this.earlyApplicationListeners);
		}

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<>();
	}
 ```
&emsp;&emsp;乍看之下这个函数没什么用，因为 initPropertySources(),getEnvironment().validateRequiredProperties() 这两段代码才是关键，但是却没有什么逻辑处理，initPropertySources是空的没有任何逻辑，而 getEnvironment().validateRequiredProperties() 也因为没有需要验证的属性而没做任何处理。其实这都是因为没有彻底理解才这么说，这个函数如果用好了作用还是挺大的。那么，该怎么用呢？我们先探索一下各个函数的作用。
&emsp;&emsp;1. initPropertySources 正符合 Spring 的开放式设计，给用户最大扩展 Spring 的能力。用户可以根据自身的需要重写 initPropertySources 方法，并在方法中进行个性化的属性处理及设置。
&emsp;&emsp;2. validateRequiredProperties 这是对属性进行验证，那么如何验证呢？我们举个小例子。
&emsp;&emsp;假如现在有这样一个需求，工程在运行过程中用到了某个设置(例如VAR)是从系统环境变量中取得，而如果用户没有在系统环境变量中配置这个参数，那么工程可能不会工作。这一要求可能会有各种各样的解决办法，当然，在Spring中可以这样做，你可以直接修改Spring的源码，例如修改ClassPathApplicationContext。当然，最好的办法还是对源码进行扩展，我可以自定义类：
 ```java
 public class MyClassPathXmlApplicationContext extends ClassPathXmlApplicationContext{
     public MyClassPathXmlApplicationContext(String... configLocations){
         super(configLocations);
     }

     protected void initPropertySources(){
         //添加验证要求
         getEnvironment().setRequiredProperties("VAR");
     }
 }
 ```
&emsp;&emsp;我们自定义了继承自 ClassPathXmlApplicationContext 的 MyClassPathXmlApplicationContext, 并重写了 initPropertySources 方法，在方法中添加了我们的个性化需求，那么在验证的时候也就是程序走到 getEnvironment().validateRequiredProperties()代码的时候， 如果系统并没有检测到对应VAR的环境变量 ，那么将抛出异常 。 当然我们还需要在使用的时候替换掉原有的ClassPathXmlApplicationContext。

## 5.4 加载 BeanFactory
&emsp;&emsp;obtainFreshBeanFactory 方法从字面理解是获取 BeanFactory。 之前有说是， ApplicationContext 是对 BeanFactory 的功能上的扩展，不但包括了 BeanFactory 的全部功能跟在其基础上添加了大量的扩展应用，那么 obatainFreshBeanFactory 正是实现 BeanFactory 的地方，也就是经过这个函数后 ApplicationContext 就已经拥有了 BeanFactory 的全部功能。
 ```java
	protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		refreshBeanFactory();
        //返回当前 BeanFactory
		return getBeanFactory();
	}
 ```
&emsp;&emsp;方法中将核心实现委托给了 refreshBeanFactory 
 ```java
	@Override
	protected final void refreshBeanFactory() throws BeansException {
		if (hasBeanFactory()) {
			destroyBeans();
			closeBeanFactory();
		}
		try {
			//创建 DefaultListableBeanFactory
			DefaultListableBeanFactory beanFactory = createBeanFactory();

			//为序列化指定id，如果需要的话，让这个 BeanFactory 从 id 反序列化到BeanFactory对象
			beanFactory.setSerializationId(getId());
			//定制 beanFactory，设置相关属性，包括是否允许覆盖同名称和不同定义的对象以及循环依赖
			//以及设置@Autowired 和 @Qualifier 注解解析器 QualifierAnnotationAutowireCandidateResolver
			customizeBeanFactory(beanFactory);
			//初始化 DocumentReader，并进行 XML文件读取及解析
			loadBeanDefinitions(beanFactory);
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
			}
		}
		catch (IOException ex) {
			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
		}
	}
 ```
&emsp;&emsp;我们详细分析上面的每个步骤。
1. 创建 DefaultListableBeanFactory。
&emsp;&emsp;在介绍 BeanFactory 的时候，声明方式为：BeanFacotry bf = new XmlBeanFactory("beanFactoryTest.xml"),其中 XmlBeanFactory 继承自 DefaultListableBeanFactory， 并提供了 XmlBeanDefinitionReader 类型的 reader，也就是所 DefaultListableBeanFactory 是容器的基础。必须首先要实例化，那么在这里就是实例化 DefaultListableBeanFactory 的步骤。
2. 指定序列化ID
3. 定制 BeanFactory
4. 加载 BeanDefinition
5. 使用全局变量记录 BeanFactory 类实例
&emsp;&emsp;因为 DefaultListableBeanFactory 类型的变量 beanFactory 是函数内的局部变量，所以要使用全局变量记录解析结果。

### 5.4.1 定制 BeanFactory
 ```java
 	protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
		//如果属性allowBeanDefinitionOverriding不为空，设置给 beanFactory 对象相应属性，
		//此属性的含义：是否允许覆盖同名称的不同定义的对象
		if (this.allowBeanDefinitionOverriding != null) {
			beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
		}
		//如果属性 allowCircularReference 不为空，设置 beanFactory 对象相应的属性。
		//此属性的含义：是否允许bean之间存在循环依赖, 在创建 bean 实例的时候又一个判断，判断是否允许循环依赖
		/**
		 * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean
		 */
		if (this.allowCircularReferences != null) {
			beanFactory.setAllowCircularReferences(this.allowCircularReferences);
		}
	}
 ```
&emsp;&emsp;对于允许覆盖和允许依赖设置这里只是判断是否为空，如果不为空要进行设置，但是并没有看到在哪里设置，究竟这个设置是在哪里进行设置的呢？还是那句话，使用之类覆盖方法，或者创建 ApplicationContext 调用对应的set方法。
> &emsp;&emsp;在5.1版本之前，这里定制BeanFactory，Spring还提供了另外一个重要的扩展，就是设置 AutowireCandidateResolver，在bean加载部分中讲解创建Bean时，如果采用autowireByType方式入住，那么会默认使用Spring提供的SimpleAutowiredandidateResolver，而对于默认的实现并没有过多的逻辑处理。在这里，Spring 使用了QualifierAnnotationAutowireCandidateResolver， 设置了这个解析器后 Spring 就可以支持注解方式的注入了。

### 6.4.2 加载BeanDefinition
&emsp;&emsp;在第一步中提到了将 ClassPathXmlApplicationContext 与 XmlBeanFactory 创建的对比，在实现配置文件的加载功能中除了我们第一步已经初始化的 DefaultListableBeanFactory 外，还需要 XmlBeanDefinitionReader 来读取 XML，那么在这个步骤中首先要做的就是初始化 XmlBeanDefinitionReader。这里就不多将了，就是创建一个 XmlBeanDefinitionReader 然后在调用其 loadBeanDefinitions 方法。 这样就把解析后的 BeanDefinitionHolder 都会注册到 DefaultListableBeanFactory 中。

## 5.5 功能扩展
&emsp;&emsp;进入函数 prepareBeanFactory 前， Spring 已经完成了对配置的解析， 而 ApplicationContext 在功能上的扩展也由此展开 。
 ```java
 	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
		//设置beanFactory 的classLoader 为当前 context 的 classLoader
		beanFactory.setBeanClassLoader(getClassLoader());
		//设置beanFactory的表达式语言处理器，Spring 3 增加了表达式语言的支持，默认可是用用 #{bean.xxx}的形式来调用相关属性值。
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
		//为 beanFactory 增加了一个默认的 propertyEditor，这个主要是对bean的属性等设置管理的一个工具
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		// 添加 BeanPostProcessor
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		//设置了几个忽略自动装配的接口
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		//设置了几个自动装配的特殊规则
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		// 增加对AspectJ的支持
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
		// 添加默认的系统环境bean
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}
 ```
&emsp;&emsp;上面的函数主要进行了几个方面的扩展
* 增加对SpEL语言的支持
* 增加对属性编辑器的支持
* 增加对一些内置类，例如 EnvironmentAware、MessageSourceAware 的信息注入。
* 设置了依赖功能可忽略的接口。
* 注册一些固定依赖的属性。
* 增加AspectJ的支持
* 将相关环境变量及属性注册以及单例模式注册。

### 5.5.1 增加SpEL语言的支持
&emsp;&emsp;Spring表达式语言全称为 Spring Expression Language， 缩写 SpEL，类似与 Struts 2x 中使用的 OGNL 表达式语言，能在运行时构造复杂表达式、存取对象图属性、对象方法调用等，并且能够与 Spring 功能完美整合，比如能用来配置 bean 定义。 SpEL 是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。
&emsp;&emsp;SpEL使用 #{...}作为定界符，所有在大括号中的字符都将被认为是SpEL，使用格式如下：
 ```xml
 <bean id="saxophone" value="com.xx.xx.Xx"/>
 <bean>
	<property name="instrument" value="#{saxophone}">
 </bean>

 <!-- 相当于 -->
 <bean id="saxophone" value="com.xx.xx.Xx"/>
 <bean>
	<property name="instrument" ref="saxophone">
 </bean>
 ```
&emsp;&emsp;当然，上面只是列举了其中最简单的使用方式，SpEL 功能非常强大，使用好可以大大提高开发效率，这里只为唤起读者的记忆来帮助我们理解源码，有兴趣的读者可以进一步深入研究。
&emsp;&emsp;在源码中通过代码 beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())) 注册语言解析器，就可以对SpEL进行解析了，那么在注册解析器后 Spring 又是在什么时候调用这个解析器进行解析呢？
&emsp;&emsp;之前我们讲解过 Spring 在bean进行初始化的时候会有填充属性的异步，而这一步中 Spring 会调用 AbstractAutowireCapableBeanFactory 类的 applyPropertyValues 函数来完成功能。 就在这个函数中，会通过构造 BeanDefinitionValueResolver 类型实例 valueResolver 来进行属性值的解析。同时，也是这个步骤中一般通过 AbstractBeanFactory 中的 evaluateBeanDefinitionString 方法去完成 SpEL 的解析。
 ```java
 	@Nullable
	protected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition) {
		if (this.beanExpressionResolver == null) {
			return value;
		}

		Scope scope = null;
		if (beanDefinition != null) {
			String scopeName = beanDefinition.getScope();
			if (scopeName != null) {
				scope = getRegisteredScope(scopeName);
			}
		}
		return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));
	}
 ```

### 5.5.2 增加属性注册编辑器
&emsp;&emsp;在 Spring DI 注入的时候可以把普通属性注入进来，但是像 Date 类型就无法识别。例如：
 ```java
 public class UserManager{
	 private Date dateValue;
	 public void setDateValue(Date dateValue){
		 this.dateValue = dateValue;
	 }
	 public Date getDateValue(){
		 return dateValue;
	 }
 }
 ```
&emsp;&emsp;上面的代码，需要对日期型属性进行注入：
 ```xml
 <bean id="userManager" class="com.test.UserManager">
 	<property name="dateValue">
	 	<value>2019-09-15</value>
	</property>
 </bean>
 ```
&emsp;&emsp;测试代码：
 ```java
 @Test
 public void testDate(){
	 ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
	 UserManager userManager = (UserManager)ctx.getBean("userManager");
	 System.out.println(userManager);
 }
 ```
&emsp;&emsp;如果直接这样使用，程序这会报异常，类型转换不成功。因为在Usermanager中的dateValue属性是Date类型，而在XML中配置的确实String类型的，所以当然会报异常。Spring针对此问题提供了两种解决办法。

#### 1. 使用自定义属性编辑器
&emsp;&emsp;使用自定义属性编辑器，通过继承 PropertyEditorSupport ，重写 setAsText 方法，具体步骤如下。
1. 编写自定义属性编辑器。
 ```java
	public class DatePropertyEditor extends PropertyEditorSupport {
		private String format = "yyyy-MM-dd";
		public void setFormat(String format){
			this.format = format;
		}
		public void setAsText(String arg0) throws IllegalArgumentException {
			System.out.println("arg0:" + arg0);
			SimpleDateFormat sdf = new SimpleDateFormate(format);
			try{
				Date d = sdf.parse(arg0);
				thi.setValue(d);
			} catch (ParseException e){
				e.printlnStackTrace();
			}
		}
	}
 ```
2. 将自定义属性编辑器注册到 Spring 中。
 ```xml
 <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="customEditors">
		<map>
			<entry key="java.util.Date">
				<bean class="com.test.DatePropertyEditor">
					<property name="format" value="yyyy-MM-dd"/>
				</bean>
			</entry>
		</map>
	</property>
 </bean>
 ```
&emsp;&emsp;在配置文件中引入类型为 org.springframework.beans.factory.config.CustomEditorConfigurer 的bean， 并在属性 customEditors 中加入自定义的属性编辑器，其中 key 为属性编辑器所对应的类型。通过这样的配置，当 Spring 在注入 bean 的属性是一旦遇到 java.util.Date 类型的属性会自动调用自定义的 DatePropertyEditor 解析器进行解析， 并用解析结果代替配置属性进行注入。

#### 2. 注入 Spring 自带的属性编辑器 CustomDateEditor
&emsp;&emsp;通过注册Spring自带的属性编辑器 CustomDateEditor， 具体步骤如下。
1. 定义属性编辑器
 ```java
 public class DatePropertyEditorRegistrar implements PropertyEditorRegistrar{
	 public void registerCustomEditors(PropertyEditorRegistry registry){
		 registry.registerCustomEditor(Date.clas, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"),true));
	 }
 }
 ```
2. 注册到 Spring 中。
 ```xml
  <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="propertyEditorRegistrars">
		<list>
			<bean class="com.test.DatePropertyEditorRegistrar"/>
		</list>
	</property>
  </bean>
 ```
&emsp;&emsp;通过在配置文件中将自定义的 DatePropertyEditorRegistrar 注册进入 org.springframework.beans.factory.config.CustomEditorConfigurer 的propertyEditorRegistrars 属性中，可以具有于方法1同样的效果。
&emsp;&emsp;讲解了这么多自定义解析器的功能，但是，似乎与 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); 并无关联，因为在注册自定义属性编辑器的时候使用的是 PropertyEditorRegistry 的registerCustomEditor 方法，而这里使用的是ConfigurableListableBeanFactory 的 addPropertyEditorRegistrar 方法。下面我们就来探索一下 ResourceEditorRegistrar 的内部实现，在 ResourceEditorRegistrar 中，我们最关心的方法是registerCustomEditors。
 ```java
 	@Override
	public void registerCustomEditors(PropertyEditorRegistry registry) {
		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, Path.class, new PathEditor(baseEditor));
		doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
		}
	}
	
	private void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {
		if (registry instanceof PropertyEditorRegistrySupport) {
			((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);
		}
		else {
			registry.registerCustomEditor(requiredType, editor);
		}
	}
 ```
&emsp;&emsp;在 registry.registerCustomEditor(requiredType, editor)，回过头来看 ResourceEditorRegistrar 类 的 registerCustomEditors 方法的核心功能，其实无非是注册了一系列的常用类型的属性编辑器， 例如，代码 doRegisterEditor(registry, Class.class, new ClassEditor(classLoader)) 实现的功能就是注册 Class 类对应的属性编辑器。那么注册后，一旦某个实体 bean 中存在一些 Class 类型的属性 ， 那么 Spring 会调用 ClassEditor 将配置中定义的 String 类型转换为 Class 类型并进行赋值。
分析到这里，我们不禁有个疑问，虽说 ResourceEditorRegistrar 类的 registerCustomEditors 方法实现了批量注册的功能 ，但是 
beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()) 仅仅是注册了 ResourceEditorRegistrar 实例，却并没有调用 ResourceEditorRegistrar 的 registerCustomEditors 方法进行注册， 那么到底是在什么时候进行注册的呢?看下 ResourceEditorRegistrar 的 registerCustomEditors 方法调用层次结构,如图:
![](images/5-1.png)
&emsp;&emsp;可以看到在 AbstractBeanFactory 中的 registerCustomEditors 方法中被调用过,继续查看 AbstractFactory 中的 registerCustomEditors 的方法又是被 initBeanWrapper 方法调用,这是在 bean 初始化时使用的一个方法,主要是在将 BeanDefinition 转化为 BeanWrapper 后对其属性的填充。在 bean 的初始化后会调用 ResourceEditorRegistrar 的 registerCustomerEditors 方法进行批量的通用属性编辑器注册。注册后, 在填充属性的环境变可以直接让 Spring 使用这些编辑器进行属性的解析了。
&emsp;&emsp;既然提到 BeanWrapper，这里也必要强调下，Spring 中用于封装 bean 的是 BeanWrapper 类型，而它又间接的继承了 PropertyEditorRegistry 类型，也就是我们之前反复看到的方法参数 PropertyEditorRegistry registry， 其实大部分情况下都是用 BeanWrapper，对于 BeanWrapper 在 Spring 中默认实现是 BeanWrapperImpl ，而 BeanWrapperImpl 除了实现 BeanWrapper 接口外还继承了 PropertyEditorRegistrySupport ，在 PropertyEditorRegistrySupport 中有这样一个方法：
 ```java
 	/**
	 * Actually register the default editors for this registry instance.
	 */
	private void createDefaultEditors() {
		this.defaultEditors = new HashMap<>(64);

		// Simple editors, without parameterization capabilities.
		// The JDK does not contain a default editor for any of these target types.
		this.defaultEditors.put(Charset.class, new CharsetEditor());
		this.defaultEditors.put(Class.class, new ClassEditor());
		this.defaultEditors.put(Class[].class, new ClassArrayEditor());
		this.defaultEditors.put(Currency.class, new CurrencyEditor());
		this.defaultEditors.put(File.class, new FileEditor());
		this.defaultEditors.put(InputStream.class, new InputStreamEditor());
		this.defaultEditors.put(InputSource.class, new InputSourceEditor());
		this.defaultEditors.put(Locale.class, new LocaleEditor());
		this.defaultEditors.put(Path.class, new PathEditor());
		this.defaultEditors.put(Pattern.class, new PatternEditor());
		this.defaultEditors.put(Properties.class, new PropertiesEditor());
		this.defaultEditors.put(Reader.class, new ReaderEditor());
		this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());
		this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());
		this.defaultEditors.put(URI.class, new URIEditor());
		this.defaultEditors.put(URL.class, new URLEditor());
		this.defaultEditors.put(UUID.class, new UUIDEditor());
		this.defaultEditors.put(ZoneId.class, new ZoneIdEditor());

		// Default instances of collection editors.
		// Can be overridden by registering custom instances of those as custom editors.
		this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));
		this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));
		this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));
		this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));
		this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));

		// Default editors for primitive arrays.
		this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());
		this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());

		// The JDK does not contain a default editor for char!
		this.defaultEditors.put(char.class, new CharacterEditor(false));
		this.defaultEditors.put(Character.class, new CharacterEditor(true));

		// Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor.
		this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));
		this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));

		// The JDK does not contain default editors for number wrapper types!
		// Override JDK primitive number editors with our own CustomNumberEditor.
		this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));
		this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));
		this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));
		this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));
		this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));
		this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));
		this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));
		this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));
		this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));
		this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));
		this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));
		this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));
		this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));
		this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));

		// Only register config value editors if explicitly requested.
		if (this.configValueEditorsActive) {
			StringArrayPropertyEditor sae = new StringArrayPropertyEditor();
			this.defaultEditors.put(String[].class, sae);
			this.defaultEditors.put(short[].class, sae);
			this.defaultEditors.put(int[].class, sae);
			this.defaultEditors.put(long[].class, sae);
		}
	}
 ```
&emsp;&emsp;具体的调用方法我们就不取详细解读了，但是至少通过这个方法我们已经知道了在 Spring 中定义了上面一系列常用的属性编辑器使我们可以方便地进行配置。如果我们定义了的 bean 中的某个属性的类型不再上面的常用配置中的话，才需要我们进行个性化属性编辑器的注册。

### 5.5.3 添加 ApplicationContextAwareProcessor 处理器
&emsp;&emsp;接下来我们对 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)) 主要目的就是注册一个 BeanPostProcessor ，而真正的逻辑还是在 ApplicationContextAwareProcessor 中。
&emsp;&emsp;ApplicationContextAwareProcessor 实现 BeanPostProcessor 接口，我们回顾一下之前讲过的内容，在 bean 实例化的时候，也就是 Spring 激活 bean 的 init-method 的前后,会调用 BeanPostProcessor 的 postProcessBeforeInitialization 方法和 postProcessAfterInitialization 方法。同样，对于 ApplicationContextAwareProcessor 我们也关心这两个方法。
&emsp;&emsp;对于 postProcessAfterInitialization 方法，在 ApplicatonContextAwareProcessor 中并没有做过多的逻辑处理。
 ```java
	@Nullable
	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
 ```
&emsp;&emsp;那么，我们重点看一下 postProcessbeforeInitialization 方法。
 ```java
 @Override
	@Nullable
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
			return bean;
		}

		AccessControlContext acc = null;

		if (System.getSecurityManager() != null) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareInterfaces(bean);
				return null;
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}

	private void invokeAwareInterfaces(Object bean) {
		if (bean instanceof EnvironmentAware) {
			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
		}
		if (bean instanceof EmbeddedValueResolverAware) {
			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
		}
		if (bean instanceof ResourceLoaderAware) {
			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
		}
		if (bean instanceof ApplicationEventPublisherAware) {
			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
		}
		if (bean instanceof MessageSourceAware) {
			((MessageSourceAware) bean).setMessageSource(this.applicationContext);
		}
		if (bean instanceof ApplicationContextAware) {
			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
		}
	}
 ```
&emsp;&emsp;postProcessBeforeinitialization 方法中调用了 invokeAwareInterfaces 。 从 invokeAwareInterfaces 方法中，我们或许已经或多或少了解了 Spring 的用意，实现这些 Aware 接口的 bean 在被初始化之后，可以取得一些对应的资源。

### 5.5.4 设置忽略依赖
&emsp;&emsp;当 Spring 将 ApplicationContextAwareProcessor 注册后，那么在invokeAwareInterfaces 方法中间接调用的 Aware 类已经不是普通的 bean 了，如 ResourceLoaderAware、ApplicationEventPublisherAware 等，那么当然需要在 Spring 做 bean 的依赖注入的时候忽略它们。而 ignoreDependencyinterface 的作用正式再次。
 ```java
	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
 ```
### 5.5.5 注册依赖
 ```java
	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
	beanFactory.registerResolvableDependency(ResourceLoader.class, this);
	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
	beanFactory.registerResolvableDependency(ApplicationContext.class, this);
 ```

## 5.6 BeanFactory 的后处理
&emsp;&emsp;BeanFactory 作为 Spring 中容器功能的基础，用于存放所有已经加载的bean，为了保证程序上的高可扩展性，Spring 针对 BeanFactory 做了大量的扩展，比如我们熟悉的 PostProcessor 等都是在这里实现的。
### 5.6.1 激活注册的 BeanFactoryPostProcessor
&emsp;&emsp;正式开始介绍之前我们先了解下 BeanFactoryPostProcessor 的用法。
&emsp;&emsp;BeanFactoryPostProcessor 接口跟 BeanPostProcessor 类似，可以对 bean 的定义(配置元数据)进行处理。也就是说，Spring IoC 容器允许BeanFactoryPostProcessor 在容器实际实例化任何其他的 bean 之前读取配置元数据，并有可能修改它。如果你愿意，你可以配置多个 BeanFactoryPostProcessor。 你还能通过设置 “order” 属性来控制 BeanFactoryPostProcessor 的执行持续(仅当 BeanFactoryPostProcessor 实现了 Ordered 接口)。请参考 BeanFactoryPostProcessor 和 Ordered 接口的 JavaDoc 以获取更详细的信息。
&emsp;&emsp;如果你想改变的 bean 实例(例如从配置元数据创建的对象)，那么你最好是用 BeanPostProcessor。同样地， BeanFactoryPostProcessor 的作用域范围是容器级的。它只和你说使用的容器有关。如果你在容器中定义了一个 BeanFactoryPostProcessor ，它仅仅对此容器的 bean 进行后置处理。BeanFactoryPostProcessor 不会对定义在另一个容器中的bean进行后置处理，即使这两个容器都在同一层次上。在Spring中存在对于 BeanFactoryPostProcessor 的典型应用，比如 PropertyPlaceholderConfigurer。
1. BeanFactoryPostProcessor 的典型应用：PropertyPlaceholderConfigurer 
&emsp;&emsp;有时候，阅读Spring的Bean描述文件时，你也许会遇到类似如下的一些配置：
 ```xml
 <bean id="message" class="distConfig.HelloMessage">
	<property name="mes">
		<value>${bean.message}</value>
	</property>
 </bean>
 ```
&emsp;&emsp;其中竟然传了变量应用：${bean.message}。这就是Spring的分散配置，可以在另外的配置文件中位 bean.message 指定值。如在bean.property 配置如下定义：
bean.message=Hi，can you find me？
&emsp;&emsp;当访问名为message的bean时，mes 属性就会被设置为字符串 “Hi，can you find me？”，但 Spring 框架是怎么知道存在这样的配置文件呢？则就要靠PropertyPlaceholderConfigurer这个类的bean：
 ```xml
 <bean id="mesHandler" class= "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations">
		<list>
			<value>config/bean.properties</value>
		</list>
	</property>
 </bean>
 ```
&emsp;&emsp;在这个bean中指定了配置文件为 config/bean.properties。到这里似乎找到了问题的答案了，但是其实还有一个问题。这个"meshandler"只不过是 Spring 框架管理的一个bean，并没有被别的bean或对象引用，Spring 的 beanFactory 是怎么知道要从这个 bean 中获取配置信息的呢？
&emsp;&emsp;查看层级结构可以看出 PropertyPlaceholderConfigurer 这个类间接继承了 BeanFactoryPostProcessor 接口。 这是一个很特别的接口，当 Spring 加载任何实现了这个接口的 bean 的配置时，都会在 bean 工厂载入所有 bean 的配置后执行 postProcessBeanFactory 方法。 在 PropertyResourceConfigurer 类中实现了 postProcessBeanFactory 方法，在方法中先调用了mergeProperties、convertProperties、processProperties 这3个方法，分别得到配置，将得到的配置转换为合适的类型，最后将配置内容告知 BeanFactory。
&emsp;&emsp;正是通过实现 BeanFactoryPostProcessor 接口，BeanFactory 会在实例化任何bean之前获得配置信息，从而能够正确的解析bean描述文件中的变量引用。
### 5.6.2 使用自定义 BeanFactoryPostProcessor
&emsp;&emsp;我们以实现一个BeanFactoryPostProcessor，去除潜在的“流氓”属性值的功能来展示自定义BeanFactoryPostProcessor的创建以及使用,例如bean定义中留下bollocks这样的字眼。
> 配置 BeanFactory.xml
 ```xml
 <bean id="bfpp" class="com.tonylee.studio.spring.beanFactoryPostProcessor.ObscenityRemovingBeanFactoryPostProcessor">
        <property name="obscenties">
            <set>
                <value>bollocks</value>
                <value>winky</value>
                <value>bum</value>
                <value>Microsoft</value>
            </set>
        </property>
    </bean>

    <bean id="simpleBean" class="com.tonylee.studio.spring.beanFactoryPostProcessor.SimplePostProcessor">
        <property name="connectionString" value="bollocks"/>
        <property name="password" value="imaginecup"/>
        <property name="username" value="Microsoft"/>
    </bean>
 ```
> ObscenityRemovingBeanFactoryPostProcessor
 ```java
 public class ObscenityRemovingBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    private Set<String> obscenties;

    public ObscenityRemovingBeanFactoryPostProcessor(){
        this.obscenties = new HashSet<String>();
    }

    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        String[] beanNames = beanFactory.getBeanDefinitionNames();
        for(String beanName : beanNames){
            BeanDefinition bd = beanFactory.getBeanDefinition(beanName);
            StringValueResolver stringValueResolver = new StringValueResolver() {
                public String resolveStringValue(String s) {
                    if(isObscene(s)){
                        return "*****";
                    }
                    return s;
                }
            };
            BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(stringValueResolver);
            visitor.visitBeanDefinition(bd);
        }
    }

    private boolean isObscene(Object value){
        String potentialObscenity = value.toString().toUpperCase();
        return this.obscenties.contains(potentialObscenity);
    }

    public void setObscenties(Set<String> obscenties){
        this.obscenties.clear();
        for(String obscenity : obscenties){
            this.obscenties.add(obscenity.toUpperCase());
        }
    }
}
 ```
> 执行类
 ```java
 public static void main(String[] args) {
		ConfigurableListableBeanFactory bf = new XmlBeanFactory(new ClassPathResource("/META-INF/BeanFactory.xml"));
		BeanFactoryPostProcessor bfpp = (BeanFactoryPostProcessor)bf.getBean("bfpp");
		bfpp.postProcessBeanFactory(bf);
		System.out.println(bf.getBean("simpleBean"));
	}
 ```
> 输出结果
SimplePostProcessor{connectionString="\*\*\*\*\*", password="imaginecup", username="\*\*\*\*\*"}

### 5.6.3 激活 BeanFactoryPostProcessor
&emsp;&emsp;了解了 BeanFactoryPostProcessor 的用法后便可以深入研究 BeanFactoryPostProcessor 的调用过程了。
>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
 ```java
 public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<>();
		//对 beanFactory 是 BeanDefinitionRegistry 类型的处理
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
			/*
			 * 硬编码注册的后处理器
			 */
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					//对于 BeanDefinitionRegistryPostProcessor 类型，在 BeanFactoryPostProcessor 的基础上还有自己定义的方法，需要先调用
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {
					// 记录常规 BeanFactoryPostProcessor
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			/**
			 * 这里不初始化 FactoryBeans ：需要保留所有未初始化的的常规bean ，以使得bean工厂后处理应用他们。
			 * 并在实现了 PriorityOrdered, Ordered, 和 其他优先级的 BeanDefinitionRegistryPostProcessor 之间分开。
			 */
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			/**
			 * 第一步、 首先调用实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor
 			 */

			//根据 BeanDefinitionRegistryPostProcessor 类型从 beanFactory 中获取到 BeanDefinitionRegistryPostProcessor bean定义；
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				/*
				 * 筛选出实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor
				 * 并添加到 currentRegistryProcessors 缓存中
				 * 同时将将该 beanName 添加到 processedBeans 缓存中
				 */
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			//对获取的 currentRegistryProcessors 的 BeanDefinitionRegistryPostProcessor 实例进行排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			//将 currentRegistryProcessors 加载到 registryProcessors 缓存中
			registryProcessors.addAll(currentRegistryProcessors);
			//激活 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			//清空当前的 currentRegistryProcessors
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			/**
			 * 接下来，调用 实现了 Ordered 的 BeanDefinitionRegistryPostProcessors 方法
			 * 逻辑与上面相同，一样是加载bean，缓存，排序，激活
			 */
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			/**
			 * 最后，调用 其他的 BeanDefinitionRegistryPostProcessors 方法
			 */
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					//若有不包含的bean，那么就需要进行循环判断，并根据前两步相同的逻辑进行处理
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			/**
			 * 现在则开始调用目前为止一处理的所有处理器的 postProcessBeanFactory 回调
			 */
			// 先处理 BeanDefinitionRegistryPostProcessor 的 postProcessBeanFactory 方法
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			// 然后处理 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}

		else {
			// Invoke factory processors registered with the context instance.
			// 如果 BeanFactory 不是 BeanDefinitionRegistry 类型的处理
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		/**
		 * 现在在获取 BeanFactoryPostProcessor 这里为什么还要获取重新获取一遍，与上面获取 BeanDefinitionRegistryPostProcessor 3 次是一样的道理
		 * 传入的参数 beanFactoryPostProcessors 可能会注册新的 BeanFactoryPostProcessor ,
		 * 所以，需要在最后一步再次获取可能在之前步骤中新注册到beanFactory的 BeanFactoryPostProcessor 并执行  postProcessBeanFactory
		 * 执行逻辑也挺相似，优先处理实现 PriorityOrdered，然后是 实现 Ordered ，最后执行其他。
		 */
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// skip - already processed in first phase above
			}
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		beanFactory.clearMetadataCache();
	}
 ```
&emsp;&emsp;上面的方法我们可以看到，对于 BeanFactoryPostProcessor 的处理主要分为两中情况进行，第一个是对于 BeanDefinitionRegistry 类的特殊处理，另一种就是对普通的 BeanFactoryPostProcessor 进行处理。而对于美中情况都需要考虑硬编码注入注册的后置处理器以及通过配置注入的后处理器。
&emsp;&emsp;对于BeanDefinitionRegistry类型的处理类的处理主要包括以下内容。
1. 对于硬编码注册的后处理器的处理，主要是通过AbstractApplicationContext 中的添加处理方法 addBeanFactoryPostProcessor 进行添加。
 ```java
 @Override
	public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
		Assert.notNull(beanPostProcessor, "BeanPostProcessor must not be null");
		// Remove from old position, if any
		this.beanPostProcessors.remove(beanPostProcessor);
		// Track whether it is instantiation/destruction aware
		if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
			this.hasInstantiationAwareBeanPostProcessors = true;
		}
		if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
			this.hasDestructionAwareBeanPostProcessors = true;
		}
		// Add to end of list
		this.beanPostProcessors.add(beanPostProcessor);
	}
 ```
&emsp;&emsp;添加后的后处理器会存放在 beanFactoryPostProcessor 中，而在处理 BeanFactoryPostProcessor 是否会检测 beanFactoryProcessors 是否有数据。当然， BeanDefinitionRegistryPostProcessor 继承自 BeanFactoryPostProcessor， 不但有 BeanFactoryPostProcessor 的特性，同时还有自己定义的个性化方法，也需要再次调用。所以，这里需要从 beanFaactoryPostProcessors 中挑选出 BeanDefinitionRegistryPostProcessor 的后处理器，并进行 postProcessBeanDefinitionRegistry 方法的激活。

2. **记录后处理器主要使用2个List完成。**
* registryProcessors : 记录通过硬编码方式注册的 BeanDefinitionRegistryPostProcessor 类型的处理器。
* regularPostProcessors : 记录通过硬编码方式注册的 BeanFactoryPostProcessor 类型的处理器。

3. 对以上说记录的 List 中的后处理器进行统一调用 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法。
4. 对 BeanFactoryPostProcessor 中非 BeanDefinitionRegistryPostProcessor 类型的后处理器进行统一的 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法调用。
5. 普通 beanFactory 处理。
&emsp;&emsp;BeanDefinitionRegistryPostProcessor 只对 BeanDefinitionRegistry 类型的 ConfigurableListableBeanFactory 有效，所以如果判断所示的 beanFactory 并不是 BeanDefinitionRegistry ，那么便可以忽略 BeanDefinitionRegistryPostProcessor， 而直接处理 BeanFactoryPostProcessor，当然获取方式与上面一致。
6. 最后再将通过 BeanDefinitionRegistryPostProcessor 发现注册的 BeanFactoryPostProcessor 后置处理器统一调用 postProcessBeanFactory 方法。

### 5.6.2 注册 BeanPostProcessor
&emsp;&emsp;上面我们提到 BeanFactoryPostProcessors 的调用，现在我们来探索下 BeanPostProcessor 的注册。真正调用其实是在 bean 的实例化阶段进行的。这是一个很重要的步骤，也是很多功能 BeanFactory 不支持的重要原因。 Spring 中大部分功能都是通过后处理器的方式进行扩展，这是 Spring 框架的一个特性，但是在 BeanFactory 中其实并没有实现后处理器的自动注册，所以在调用的时候如果没有进行手动注册其实是不能使用的。但是在 ApplicationContext 中却添加了自动注册功能。实现该功能的就是 AbstractApplicationContext#refresh 方法中的 registerBeanPostProcessors(beanFactory); 
 ```java
 public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		/**
		 * 注册BeanPostProcessorChecker，当在BeanPostProcessor实例化期间创建Bean时，
		 * 即当某个Bean不适合所有BeanPostProcessor处理时，记录一条信息消息。
		 */
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		//将 实现了 PriorityOrdered、Ordered和其他的分隔开
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		// 第一步， 注册 实现了 PriorityOrdered 的 BeanPostProcessors
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
		// 第二步， 注册 实现了 Ordered 的 BeanPostProcessors
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
		// 现在 注册其他普通的 BeanPostProcessors
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
		// 最后注册 实现了 MergedBeanDefinitionPostProcessor 的 BeanPostProcessors
		sortPostProcessors(internalPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		// 重新注册后处理器以将内部bean检测为ApplicationListener，将其移至处理器链的末尾（用于拾取代理等）。
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
 ```
&emsp;&emsp;配合源码以及注释，在 registerBeanPostProcessor 方法中所做的逻辑；我们会发现，对于 BeanPostProcessor 的处理与 BeanFactoryPostProcessor 的处理极为相似，但是师傅又有一些不同的地方。经过对比发现，对于 BeanFactoryPostProcessor 的处理要区分两种情况，一种是通过硬编码方式的处理，另一种是通过配置方式的处理。那么为什么 BeanPostProcessor 的处理中只考虑了配置文件的方式而不考虑硬编码的方式呢？提出这个问题，还是因为咱们没有完全理解两者实现的功能。**对于 BeanFactoryPostProcessor 的处理，不但要实现注册功能，而且还要实现对后处理器的激活操作，所以需要载入配置中的定义，并激活；而对于 BeanPostProcessor 并不需要马上调用，再说，硬编码额方式实现的功能是将后处理器提取并调用，这里并不需要调动，当然不需要考虑硬编码的方式呢，这里的功能只需要将配置的 BeanPostProcessor 提取出来并注册进入 beanFacotry 就可以了。**
&emsp;&emsp;对于 beanFactory 的注册，也不是直接注册就可以的。在 Spring 中支持对 BeanPostProcessor 的排序，比如根据 PriorityOrdered 进行排序、根据Ordered进行排序或者无须，而Spring在 BeanPostProcessor 的激活顺序的时候也会考虑对于顺序的问题而先进行排序。

### 5.6.3 初始化消息资源
&emsp;&emsp;在进行这段函数的解析之前，我们同样先来回顾 Spring 国际化的使用方法。
&emsp;&emsp;假设我们正在开发一个支持躲过语言的 Web 应用程序，要求系统能够根据客户端的系统的语言类型返回对应的界面：英文操作系统返回英文界面，而中文操作系统则返回中文界面——这便是典型的il8n国际化问题。对于有国际化要求的引用系统，我们不能简单地采用硬编码的方式编写用户界面信息、报错信息等内容，而必须为这些需要国际化的信息进行特殊处理。简单来说，就是为每种语言提供一套相应的资源文件，并以规范命名的方式保存在特定的目录中，由系统自动根据客户端语言选择合适的资源文件。
&emsp;&emsp;"国际化信息"也被称为"本地化信息"，一般需要两个条件才可以确定一个特殊类型的本地化信息，它们分别是“语言类型”和“国家/地区的类型”。如中文本地化信息既有中国大陆地区的中文，又有中国台湾地区、中国香港地区的中文，还有新加坡地区的中文。Java 通过 java.util.Locale 类表示一个本地化对象，它允许通过语言参数和国家/地区参数创建一个确定的本地化对象。
&emsp;&emsp;java.util.Locale 是表示语言和国家/地区信息的本地化类，它是创建国际化应用的基础。下面来给出几个创建本地化对象的示例：
 ```java
	// 带有语言和国家/地区信息的本地化对象
	Locale locale1 = new Locale("zh","CN");
	// 只有语言信息的本地化对象
	Locale locale2 = new Locale("zh");
	// 等同于 Locale("zh","CN")
	Locale locale3 = Locale.CHINA;
	// 等同于Locale("zh")
	Locale locale4 = Locale.CHINESE;
	// 获取本地系统默认的本地化对象
	Locale locale5 = Locale.getDefault();
 ```
&emsp;&emsp;JDK 的 java.util 包中提供了几个支持本地化的格式化操作工具类：NumberFormat、DateFormat、MessageFormat，而在 Spring 中的国际化资源操作也无非是对这些类的封装操作，我们仅仅介绍下 MessageFormat 的用法以帮助大家回顾：
 ```java
	//信息格式化串
	String pattern1 = "{0}, 你好！你于{1}在工商银行存入{2}元。";
	String pattern2 = "At {1,time,short} On {1,date,long} {0} paid {2, number, currency}.";
	
	//用于动态替换占位符的参数
	Object[] params = {"John", new GregorianCalendar().getTime(),1.0E3};

	//使用默认本地化对象格式化信息
	String msg1 = MessageFormat.format(pattern1, params);
	//使用指定的本地化文件格式化信息
	MessageFormat mf = new MessageFormat(pattern2,Locale.US);
	String msg2 = mf.format(params);
	System.out.println(msg1);
	System.out.println(msg2);
 ```
&emsp;&emsp;Spring 定义了访问国际化信息的 MessageSource 接口，并提供了几个易用的实现类。MessageSource 分别被HierarchicalMessageSource 和 ApplicationContext 接口扩展，这里我们主要看下 HierarchicalMessageSource 接口的几个实现类，如图所示。
![](images/5-6-3-1.png)
&emsp;&emsp;HierarchicalMessageSource 接口最重要的两个实现类是 ResourceBundleMessageSource 和 ReloadableResourceBundleMessageSource 。它们基于 Java 的ResourceBundle 基础类实现，允许通过资源名加载国际化资源。 ReloadableResourceBundleMessageSource 提供了定时刷新功能，允许在不重启系统的情况下，更新资源的信息。 StaticMessageSource 主要用于程序测试，它允许通过编码的方式提供国际化信息。 而 DelegatingMessageSource 是为了方便操作父 MessageSource 而提供的代理类。仅仅举例 ResourceBundleMessageSource 的实现方式。
1. 定义资源文件
* messages.properties(默认：因为),内容仅一句，如下：
test=test
* message_zh_CN.properties(简体中文):
test=测试
&emsp;&emsp;然后打开命令行，输入 native2asscii -encoding gbk message_zh_CN.properties message_zh_CN_tem.properties,并将 message_zh_CN_tem.properties 内容替换到 message_zh_CN.properties 中，这样  message_zh_CN.properties 文件就存放的是转码后的内容，比较简单
2. 定义配置文件
 ```xml
	<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basenames">
            <list>
                <value>il18n/messages</value>
            </list>
        </property>
    </bean>
 ```
&emsp;&emsp;其中，这个Bean的ID 必须命名为messageSource,否则会抛出 NoSuchMessageException 异常。
3. 使用ApplicationContext访问国际化信息
 ```java
	ApplicationContext ctx = new ClassPathXmlApplicationContext("META-INF/il18nMessage.xml");
	Object[] params = {"John", new GregorianCalendar().getTime()};
	String str1 = ctx.getMessage("test", params, Locale.US);
	String str2 = ctx.getMessage("test", params, Locale.CHINA);
	System.out.println(str1);
	System.out.println(str2);
 ```
&emsp;&emsp;了解了Spring国际化的使用后便可以进行源码的分析了。
&emsp;&emsp;在 initMessageSource 中的方法主要功能是提取配置中定义的 messageSource，并将其记录在Spring的容器中，也就是 AbstractApplicationContext 中。当然，如果用户未设置资源文件的话，Spring 中也提供了默认的配置 DelegationMessageSource。
&emsp;&emsp;在 initMessageSource 中获取自定义资源的方式为 beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class),在这里 Spring 使用了硬编码性规定了子资源文件必须为 message ,否则会获取不到自定义配置资源，这也是为什么之前跳Bean 的id 如果不为 message 会抛出异常。
 ```java
 protected void initMessageSource() {
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
			//如果配置了 messageSource ，那么将 messageSource 记录在 this.messageSource 中
			this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
			// Make MessageSource aware of parent MessageSource.
			if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
				HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
				if (hms.getParentMessageSource() == null) {
					// Only set parent context as parent MessageSource if no parent MessageSource
					// registered already.
					hms.setParentMessageSource(getInternalParentMessageSource());
				}
			}
			if (logger.isTraceEnabled()) {
				logger.trace("Using MessageSource [" + this.messageSource + "]");
			}
		}
		else {
			// Use empty MessageSource to be able to accept getMessage calls.
			//如果用户并没有定义配置，那么使用临时的 DelegatingMessageSource 以便于作为调用 getMessage 方法的返回
			DelegatingMessageSource dms = new DelegatingMessageSource();
			dms.setParentMessageSource(getInternalParentMessageSource());
			this.messageSource = dms;
			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
			if (logger.isTraceEnabled()) {
				logger.trace("No '" + MESSAGE_SOURCE_BEAN_NAME + "' bean, using [" + this.messageSource + "]");
			}
		}
	}
 ```
&emsp;&emsp;通过读]我并将 自定义资源文件配置记录在容器中，那么就可以在获取资源文件的时候直接使用了 ，例如 ，在 AbstractApplicationContext 中的获取资源文件属性的方法
 ```java
 	@Override
	public String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {
		return getMessageSource().getMessage(code, args, locale);
	}
 ```

### 5.6.4 初始化 ApplicationEventMulticaster
&emsp;&emsp;我们首先来看下Spring事件监听的简单用法。
1. 定义监听事件
 ```java
 public class TestEvent extends ApplicationEvent {

    private String msg;

    public TestEvent(Object source) {
        super(source);
    }

    public TestEvent(Object source, String msg){
        super(source);
        this.msg = msg;
    }

    public void print(){
        System.out.println(msg);
    }
}
 ```
2. 定义监听器
 ```java
 public class TestEventListener implements ApplicationListener {
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        if(applicationEvent instanceof TestEvent){
            ((TestEvent)applicationEvent).print();
        }
    }
}
 ```
3. 配置文件
 ```xml
 <bean id="testListener" class="info.tonylee.studio.spring.eventListner.TestEventListener"/>
 ```
4. 测试
 ```java
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("META-INF/test-event-listener.xml");
		context.publishEvent(new TestEvent("hello", "msg"));
	}
 ```
&emsp;&emsp;这里很多人就会反映出设计模式中的观察者模式，这确实是个典型的引用，可以在比较关心的事件结束后及时处理。那么我们看看 ApplicationEventMulticaster 是如何被初始化的，以确保功能的正确运行。
&emsp;&emsp; initApplicationEventMulticaster 的方式比较简单，无非考略两种情况。
* 如果用户自定义了事件广播器，那么使用用户自定义的事件广播器。
* 如果用户没有自定义事件广播器，那么使用默认的 ApplicationEventMulticaster。
 ```java
 protected void initApplicationEventMulticaster() {
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
			this.applicationEventMulticaster =
					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
			if (logger.isTraceEnabled()) {
				logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
			}
		}
		else {
			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
			if (logger.isTraceEnabled()) {
				logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " +
						"[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");
			}
		}
	}
 ```
&emsp;&emsp;按照之前的介绍，作为广播器，一定是用于存放监听器并在合适的时候调用监听器，那么我们不妨进入默认的广播器实现 SimpleApplicationEventMulticaster 来一探究竟。
 ```java
	@Override
	public void multicastEvent(ApplicationEvent event) {
		multicastEvent(event, resolveDefaultEventType(event));
	}

	@Override
	public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		Executor executor = getTaskExecutor();
		for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
			if (executor != null) {
				executor.execute(() -> invokeListener(listener, event));
			}
			else {
				invokeListener(listener, event);
			}
		}
	}
 ```
&emsp;&emsp;可以推断，当产生 Spring 事件的事件的时候会默认使用 SimpleApplicationEventMulticaster 的 multicastEvent 来广播事件，遍历所有支持该类型的监听器，并使用监听器中的 onApplicationEvent 方法来进行监听器的处理。而对于每个监听器来说其实都可以获取到生产的事件，同时时候处理事件也可以由监听器自己来决定。
 ```java
 protected Collection<ApplicationListener<?>> getApplicationListeners(
			ApplicationEvent event, ResolvableType eventType) {

		//获取事件资源，针对 ApplicationEvent 一般都是 SpringApplication spring 应用对象
		Object source = event.getSource();
		//获取对应的 资源 class
		Class<?> sourceType = (source != null ? source.getClass() : null);
		//创建一个监听的缓存key
		ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);

		// Quick check for existing entry on ConcurrentHashMap...
		//快速检查 该事件的 listener
		ListenerRetriever retriever = this.retrieverCache.get(cacheKey);
		if (retriever != null) {
			return retriever.getApplicationListeners();
		}

		if (this.beanClassLoader == null ||
				(ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &&
						(sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) {
			// Fully synchronized building and caching of a ListenerRetriever
			// 双重检查，再次从缓存中获取
			synchronized (this.retrievalMutex) {
				retriever = this.retrieverCache.get(cacheKey);
				if (retriever != null) {
					return retriever.getApplicationListeners();
				}
				//为空，则查找 ApplicationListeners
				retriever = new ListenerRetriever(true);
				Collection<ApplicationListener<?>> listeners =
						retrieveApplicationListeners(eventType, sourceType, retriever);
				this.retrieverCache.put(cacheKey, retriever);
				return listeners;
			}
		}
		else {
			// No ListenerRetriever caching -> no synchronization necessary
			return retrieveApplicationListeners(eventType, sourceType, null);
		}
	}
 ```
&emsp;&emsp;上面的代码，主要内容就是从缓存中获取 listener 如果获取不到再从 retrieveApplicationListeners 中获取，也就是说 retrieveApplicationListeners 这个才是获取 listener 的核心方法。
 ```java
	private Collection<ApplicationListener<?>> retrieveApplicationListeners(
			ResolvableType eventType, @Nullable Class<?> sourceType, @Nullable ListenerRetriever retriever) {

		List<ApplicationListener<?>> allListeners = new ArrayList<>();
		Set<ApplicationListener<?>> listeners;
		Set<String> listenerBeans;
		synchronized (this.retrievalMutex) {
			//获取注册到 ApplicationEventMulticaster 里面 监听器
			listeners = new LinkedHashSet<>(this.defaultRetriever.applicationListeners);
			listenerBeans = new LinkedHashSet<>(this.defaultRetriever.applicationListenerBeans);
		}

		// Add programmatically registered listeners, including ones coming
		// from ApplicationListenerDetector (singleton beans and inner beans).
		// 添加以编码方式注册的监听器，包括来自ApplicationListenerDetector(单个bean和内部bean)的监听器
		for (ApplicationListener<?> listener : listeners) {
			if (supportsEvent(listener, eventType, sourceType)) {
				if (retriever != null) {
					retriever.applicationListeners.add(listener);
				}
				allListeners.add(listener);
			}
		}

		// Add listeners by bean name, potentially overlapping with programmatically
		// registered listeners above - but here potentially with additional metadata.
		// 通过 bean 名称添加监听器，可能与上面的变成方式注册监听器重叠，但是这里可能带有其他元数据。
		if (!listenerBeans.isEmpty()) {
			ConfigurableBeanFactory beanFactory = getBeanFactory();
			for (String listenerBeanName : listenerBeans) {
				try {
					//判断该监听器是否支持该事件类型
					if (supportsEvent(beanFactory, listenerBeanName, eventType)) {
						ApplicationListener<?> listener =
								beanFactory.getBean(listenerBeanName, ApplicationListener.class);
						if (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {
							if (retriever != null) {
								if (beanFactory.isSingleton(listenerBeanName)) {
									retriever.applicationListeners.add(listener);
								}
								else {
									retriever.applicationListenerBeans.add(listenerBeanName);
								}
							}
							allListeners.add(listener);
						}
					}
					else {
						// Remove non-matching listeners that originally came from
						// ApplicationListenerDetector, possibly ruled out by additional
						// BeanDefinition metadata (e.g. factory method generics) above.
						Object listener = beanFactory.getSingleton(listenerBeanName);
						if (retriever != null) {
							retriever.applicationListeners.remove(listener);
						}
						allListeners.remove(listener);
					}
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Singleton listener instance (without backing bean definition) disappeared -
					// probably in the middle of the destruction phase
				}
			}
		}

		AnnotationAwareOrderComparator.sort(allListeners);
		if (retriever != null && retriever.applicationListenerBeans.isEmpty()) {
			retriever.applicationListeners.clear();
			retriever.applicationListeners.addAll(allListeners);
		}
		return allListeners;
	}
 ```
&emsp;&emsp;retrieveApplicationListeners 主要的几个步骤就是：
1. 从注册的 listenner 中 获取所有的 listener 然后，通过 supportsEvent(listener, eventType, sourceType) 检查 是否支持该事件类型。
2. 从 beanFactory 中根据 listenerBean 获取 listener 通过 supportsEvent(beanFactory, listenerBeanName, eventType) 再次判断是否支持该事件类型，并且如果相同的listener 会先将第1步的移除，再添加这次获取的。
### 5.6.5 注册监听器
 ```java
 protected void registerListeners() {
		// Register statically specified listeners first.
		// 首先注册静态自定义的监听器
		for (ApplicationListener<?> listener : getApplicationListeners()) {
			getApplicationEventMulticaster().addApplicationListener(listener);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let post-processors apply to them!
		// 通过配置注册监听器
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
		for (String listenerBeanName : listenerBeanNames) {
			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
		}

		// Publish early application events now that we finally have a multicaster...
		// 可以发布早期(context启动时期间)的引用程序事件。
		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
		this.earlyApplicationEvents = null;
		if (earlyEventsToProcess != null) {
			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
				getApplicationEventMulticaster().multicastEvent(earlyEvent);
			}
		}
	}
 ```
### 5.7 初始化非延迟加载单例
&emsp;&emsp;完成 BeanFactory 的初始化工作，其中 包括 ConversionService 的设置、配置冻结以及非延迟加载的 bean 的初始化工作。
 ```java
	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
		// Initialize conversion service for this context.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
			beanFactory.setConversionService(
					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}

		// Register a default embedded value resolver if no bean post-processor
		// (such as a PropertyPlaceholderConfigurer bean) registered any before:
		// at this point, primarily for resolution in annotation attribute values.
		//如果之前没有任何bean后处理器（例如PropertyPlaceholderConfigurer Bean）进行过注册，请注册一个默认的嵌入式值解析器：此时，主要用于注释属性值的解析。
		if (!beanFactory.hasEmbeddedValueResolver()) {
			beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
		}

		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
		// 尽早初始化LoadTimeWeaverAware Bean，以便尽早注册其转换器。
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
			getBean(weaverAwareName);
		}

		// Stop using the temporary ClassLoader for type matching.
		beanFactory.setTempClassLoader(null);

		// Allow for caching all bean definition metadata, not expecting further changes.
		// 冻结所有的 bean 定义，
		beanFactory.freezeConfiguration();

		// Instantiate all remaining (non-lazy-init) singletons.
		// 初始化剩下的单实例(非惰性)
		beanFactory.preInstantiateSingletons();
	}
 ```
&emsp;&emsp;首先我们来了解一下 ConversionService 类所提供的作用。
1. ConversionService 的设置
&emsp;&emsp; 之前我们提到过使用自定义类型转换从 String 转换为 Date 的方式，那么，在Spring中还提供了另一种转换方式：使用Converter。同样，我们使用一个简单的示例来了解下 Converter 的使用方式。

2. 冻结配置
&emsp;&emsp;冻结所有bean的定义，说明注册的bean定义将不被修改或进行任何进一步的处理。
 ```java
 	@Override
	public void freezeConfiguration() {
		this.configurationFrozen = true;
		this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
	}
 ```
3. 初始化非延迟加载
&emsp;&emsp;ApplicationContext 实现的默认行为就是在启动时将所有单例 bean 提前进行实例化。提前实例化意味着作为初始化过程的一部分， ApplicationContext 实例会创建并配置所有的单例 bean。通常情况下这是意见好事，因为这样在配置中的任何错误就会即刻被发现(否则的话可能要花几个小时甚至几天)。而这个实例化的过程就还是在 finishBeanFactoryInitialization 中完成的。
 ```java
 	public void preInstantiateSingletons() throws BeansException {
		if (logger.isTraceEnabled()) {
			logger.trace("Pre-instantiating singletons in " + this);
		}

		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
					if (bean instanceof FactoryBean) {
						final FactoryBean<?> factory = (FactoryBean<?>) bean;
						boolean isEagerInit;
						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
							isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)
											((SmartFactoryBean<?>) factory)::isEagerInit,
									getAccessControlContext());
						}
						else {
							isEagerInit = (factory instanceof SmartFactoryBean &&
									((SmartFactoryBean<?>) factory).isEagerInit());
						}
						if (isEagerInit) {
							getBean(beanName);
						}
					}
				}
				else {
					getBean(beanName);
				}
			}
		}

		// Trigger post-initialization callback for all applicable beans...
		for (String beanName : beanNames) {
			Object singletonInstance = getSingleton(beanName);
			if (singletonInstance instanceof SmartInitializingSingleton) {
				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
				if (System.getSecurityManager() != null) {
					AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
						smartSingleton.afterSingletonsInstantiated();
						return null;
					}, getAccessControlContext());
				}
				else {
					smartSingleton.afterSingletonsInstantiated();
				}
			}
		}
	}
 ```
## 5.8 finishRefresh
&emsp;&emsp; 在 Spring 中还提供了 Lifecycle 接口，Lifecycle 中包含 start/stop 方法，实现此接口后 Spring 会保证在启动的时候调用其 start 方法开始生命周期，并在 Spring 关闭的时候调用 stop 方法来结束声明周期，通常用来配置后台程序，在启动后一直运行(如对MQ进行轮询等)。而 ApplicationContext 的初始化最后正式保证了这一功能的实现。
 ```java
 	protected void finishRefresh() {
		// Clear context-level resource caches (such as ASM metadata from scanning).
		clearResourceCaches();

		// Initialize lifecycle processor for this context.
		initLifecycleProcessor();

		// Propagate refresh to lifecycle processor first.
		getLifecycleProcessor().onRefresh();

		// Publish the final event.
		publishEvent(new ContextRefreshedEvent(this));

		// Participate in LiveBeansView MBean, if active.
		LiveBeansView.registerApplicationContext(this);
	}
 ```
1. initLifecycleProcessor
&emsp;&emsp;当 ApplicationContext 启动或停止时，它会通过 LifecycleProcessor 来与所有声明的 bean 的周期做状态更新，而在 LifecycleProcessor 的使用前需要初始化。
 ```java
 	protected void initLifecycleProcessor() {
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
			this.lifecycleProcessor =
					beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
			if (logger.isTraceEnabled()) {
				logger.trace("Using LifecycleProcessor [" + this.lifecycleProcessor + "]");
			}
		}
		else {
			DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
			defaultProcessor.setBeanFactory(beanFactory);
			this.lifecycleProcessor = defaultProcessor;
			beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
			if (logger.isTraceEnabled()) {
				logger.trace("No '" + LIFECYCLE_PROCESSOR_BEAN_NAME + "' bean, using " +
						"[" + this.lifecycleProcessor.getClass().getSimpleName() + "]");
			}
		}
	}
 ```
2. onRefresh
&emsp;&emsp;启动所有实现了 Lifecycle 接口的 bean。
 ```java
 	@Override
	public void onRefresh() {
		startBeans(true);
		this.running = true;
	}
	private void startBeans(boolean autoStartupOnly) {
		Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
		Map<Integer, LifecycleGroup> phases = new HashMap<>();
		lifecycleBeans.forEach((beanName, bean) -> {
			if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {
				int phase = getPhase(bean);
				LifecycleGroup group = phases.get(phase);
				if (group == null) {
					group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
					phases.put(phase, group);
				}
				group.add(beanName, bean);
			}
		});
		if (!phases.isEmpty()) {
			List<Integer> keys = new ArrayList<>(phases.keySet());
			Collections.sort(keys);
			for (Integer key : keys) {
				phases.get(key).start();
			}
		}
	}
 ```
3. publishEvent
&emsp;&emsp;当完成 ApplicationContext 初始化的时候，要通过 Spring 中的事件发布机制来发出 ContextRefreshedEvent 事件，以保证对应的监听器可以做进一步的逻辑催了。
 ```java
 	protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
		Assert.notNull(event, "Event must not be null");

		// Decorate event as an ApplicationEvent if necessary
		ApplicationEvent applicationEvent;
		if (event instanceof ApplicationEvent) {
			applicationEvent = (ApplicationEvent) event;
		}
		else {
			applicationEvent = new PayloadApplicationEvent<>(this, event);
			if (eventType == null) {
				eventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();
			}
		}

		// Multicast right now if possible - or lazily once the multicaster is initialized
		if (this.earlyApplicationEvents != null) {
			this.earlyApplicationEvents.add(applicationEvent);
		}
		else {
			getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
		}

		// Publish event via parent context as well...
		if (this.parent != null) {
			if (this.parent instanceof AbstractApplicationContext) {
				((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
			}
			else {
				this.parent.publishEvent(event);
			}
		}
	}
 ```